From ae9ffb2e7edfb9d7b4bf035b5ab22fe60047674c Mon Sep 17 00:00:00 2001
From: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
Date: Fri, 19 Jul 2024 19:12:38 +0530
Subject: [PATCH 01/11] clk: qcom: gcc-sm8250: Do not turn off PCIe GDSCs
 during gdsc_disable()

With PWRSTS_OFF_ON, PCIe GDSCs are turned off during gdsc_disable(). This
can happen during scenarios such as system suspend and breaks the resume
of PCIe controllers from suspend.

So use PWRSTS_RET_ON to indicate the GDSC driver to not turn off the GDSCs
during gdsc_disable() and allow the hardware to transition the GDSCs to
retention when the parent domain enters low power state during system
suspend.

Cc: stable@vger.kernel.org # 5.7
Fixes: 3e5770921a88 ("clk: qcom: gcc: Add global clock controller driver for SM8250")
Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
---
 drivers/clk/qcom/gcc-sm8250.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/clk/qcom/gcc-sm8250.c b/drivers/clk/qcom/gcc-sm8250.c
index 991cd8b8d59726..1c59d70e0f96c5 100644
--- a/drivers/clk/qcom/gcc-sm8250.c
+++ b/drivers/clk/qcom/gcc-sm8250.c
@@ -3226,7 +3226,7 @@ static struct gdsc pcie_0_gdsc = {
 	.pd = {
 		.name = "pcie_0_gdsc",
 	},
-	.pwrsts = PWRSTS_OFF_ON,
+	.pwrsts = PWRSTS_RET_ON,
 };
 
 static struct gdsc pcie_1_gdsc = {
@@ -3234,7 +3234,7 @@ static struct gdsc pcie_1_gdsc = {
 	.pd = {
 		.name = "pcie_1_gdsc",
 	},
-	.pwrsts = PWRSTS_OFF_ON,
+	.pwrsts = PWRSTS_RET_ON,
 };
 
 static struct gdsc pcie_2_gdsc = {
@@ -3242,7 +3242,7 @@ static struct gdsc pcie_2_gdsc = {
 	.pd = {
 		.name = "pcie_2_gdsc",
 	},
-	.pwrsts = PWRSTS_OFF_ON,
+	.pwrsts = PWRSTS_RET_ON,
 };
 
 static struct gdsc ufs_card_gdsc = {

From 74836efc38bbd6b9aacc41fd669d2050080c1091 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 9 Sep 2024 21:24:16 +0800
Subject: [PATCH 02/11] ASoC: qcom: q6asm-dai: Change some default periods

---
 sound/soc/qcom/qdsp6/q6asm-dai.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/sound/soc/qcom/qdsp6/q6asm-dai.c b/sound/soc/qcom/qdsp6/q6asm-dai.c
index 3913706ccdc5f1..a4b1a32d2a123c 100644
--- a/sound/soc/qcom/qdsp6/q6asm-dai.c
+++ b/sound/soc/qcom/qdsp6/q6asm-dai.c
@@ -25,8 +25,8 @@
 
 #define PLAYBACK_MIN_NUM_PERIODS    2
 #define PLAYBACK_MAX_NUM_PERIODS   8
-#define PLAYBACK_MAX_PERIOD_SIZE    65536
-#define PLAYBACK_MIN_PERIOD_SIZE    128
+#define PLAYBACK_MAX_PERIOD_SIZE    7168
+#define PLAYBACK_MIN_PERIOD_SIZE    8
 #define CAPTURE_MIN_NUM_PERIODS     2
 #define CAPTURE_MAX_NUM_PERIODS     8
 #define CAPTURE_MAX_PERIOD_SIZE     4096

From 2a11a66028a05aa8ccc51c86a66b287ea0a41085 Mon Sep 17 00:00:00 2001
From: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date: Thu, 15 Aug 2024 18:05:42 +0100
Subject: [PATCH 03/11] arm64: dts: qcom: sm8250: move lpass codec macros to
 use clks directly

Move lpass codecs va and wsa macros to use the clks directly from
AFE clock controller instead of going via gfm mux like other codec macros
and SoCs.

This makes it more align with the other SoCs and codec macros in this SoC
which take AFE clocks directly. This will also avoid an extra clk mux layer,
provides consistency and avoids the buggy mux driver which will be removed.

This should also fix RB5 audio.

Remove the gfm mux drivers for both audiocc and aoncc.

Change-Id: I22350f0c5ab8371efe8e62cf65ddb873f268a785
Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Link: https://lore.kernel.org/r/20240815170542.20754-1-srinivas.kandagatla@linaro.org
Signed-off-by: Bjorn Andersson <andersson@kernel.org>
---
 arch/arm64/boot/dts/qcom/sm8250.dtsi | 31 ++++------------------------
 1 file changed, 4 insertions(+), 27 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250.dtsi b/arch/arm64/boot/dts/qcom/sm8250.dtsi
index 9d6c97d1fd9d6e..630f4eff20bf81 100644
--- a/arch/arm64/boot/dts/qcom/sm8250.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250.dtsi
@@ -8,8 +8,6 @@
 #include <dt-bindings/clock/qcom,gcc-sm8250.h>
 #include <dt-bindings/clock/qcom,gpucc-sm8250.h>
 #include <dt-bindings/clock/qcom,rpmh.h>
-#include <dt-bindings/clock/qcom,sm8250-lpass-aoncc.h>
-#include <dt-bindings/clock/qcom,sm8250-lpass-audiocc.h>
 #include <dt-bindings/dma/qcom-gpi.h>
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/interconnect/qcom,osm-l3.h>
@@ -2633,14 +2631,13 @@
 		wsamacro: codec@3240000 {
 			compatible = "qcom,sm8250-lpass-wsa-macro";
 			reg = <0 0x03240000 0 0x1000>;
-			clocks = <&audiocc LPASS_CDC_WSA_MCLK>,
-				 <&audiocc LPASS_CDC_WSA_NPL>,
+			clocks = <&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				 <&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK  LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
 				 <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
 				 <&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
-				 <&aoncc LPASS_CDC_VA_MCLK>,
 				 <&vamacro>;
 
-			clock-names = "mclk", "npl", "macro", "dcodec", "va", "fsgen";
+			clock-names = "mclk", "npl", "macro", "dcodec", "fsgen";
 
 			#clock-cells = <0>;
 			clock-output-names = "mclk";
@@ -2674,20 +2671,10 @@
 			status = "disabled";
 		};
 
-		audiocc: clock-controller@3300000 {
-			compatible = "qcom,sm8250-lpass-audiocc";
-			reg = <0 0x03300000 0 0x30000>;
-			#clock-cells = <1>;
-			clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
-				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
-				<&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
-			clock-names = "core", "audio", "bus";
-		};
-
 		vamacro: codec@3370000 {
 			compatible = "qcom,sm8250-lpass-va-macro";
 			reg = <0 0x03370000 0 0x1000>;
-			clocks = <&aoncc LPASS_CDC_VA_MCLK>,
+			clocks = <&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
 				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
 				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
 
@@ -2792,16 +2779,6 @@
 			#size-cells = <0>;
 		};
 
-		aoncc: clock-controller@3380000 {
-			compatible = "qcom,sm8250-lpass-aoncc";
-			reg = <0 0x03380000 0 0x40000>;
-			#clock-cells = <1>;
-			clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
-				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
-				<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
-			clock-names = "core", "audio", "bus";
-		};
-
 		lpass_tlmm: pinctrl@33c0000 {
 			compatible = "qcom,sm8250-lpass-lpi-pinctrl";
 			reg = <0 0x033c0000 0x0 0x20000>,

From 26bc8ec2a3b4a59a08e50fa764ddf1337c8db3ac Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:16:22 +0800
Subject: [PATCH 04/11] arm64: dts: qcom: sm8250: add uart16

---
 arch/arm64/boot/dts/qcom/sm8250.dtsi | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/sm8250.dtsi b/arch/arm64/boot/dts/qcom/sm8250.dtsi
index 630f4eff20bf81..c4ab889237e111 100644
--- a/arch/arm64/boot/dts/qcom/sm8250.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250.dtsi
@@ -1153,6 +1153,23 @@
 				status = "disabled";
 			};
 
+			uart16: serial@888000 {
+				compatible = "qcom,geni-uart";
+				reg = <0 0x00888000 0 0x4000>;
+				clock-names = "se";
+				clocks = <&gcc GCC_QUPV3_WRAP2_S2_CLK>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&qup_uart16_default>;
+				interrupts = <GIC_SPI 584 IRQ_TYPE_LEVEL_HIGH>;
+				power-domains = <&rpmhpd RPMHPD_CX>;
+				operating-points-v2 = <&qup_opp_table>;
+				interconnects = <&qup_virt MASTER_QUP_CORE_2 0 &qup_virt SLAVE_QUP_CORE_2 0>,
+						<&gem_noc MASTER_AMPSS_M0 0 &config_noc SLAVE_QUP_2 0>;
+				interconnect-names = "qup-core",
+						     "qup-config";
+				status = "disabled";
+			};
+
 			i2c17: i2c@88c000 {
 				compatible = "qcom,geni-i2c";
 				reg = <0 0x0088c000 0 0x4000>;
@@ -5725,6 +5742,11 @@
 				function = "qup12";
 			};
 
+			qup_uart16_default: qup-uart16-default-state {
+				pins = "gpio50", "gpio51";
+				function = "qup16";
+			};
+
 			qup_uart17_default: qup-uart17-default-state {
 				pins = "gpio52", "gpio53", "gpio54", "gpio55";
 				function = "qup17";

From 65850fcb22f34505944688f878b0b10b7b6c6a8b Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 30 Sep 2024 14:43:45 +0700
Subject: [PATCH 05/11] drm: panel: Add DDIC CH13726A panel

---
 drivers/gpu/drm/panel/Kconfig               |  11 +
 drivers/gpu/drm/panel/Makefile              |   1 +
 drivers/gpu/drm/panel/panel-ddic-ch13726a.c | 325 ++++++++++++++++++++
 3 files changed, 337 insertions(+)
 create mode 100644 drivers/gpu/drm/panel/panel-ddic-ch13726a.c

diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 9f49b0189d3b83..c6fcccdcffa077 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -87,6 +87,17 @@ config DRM_PANEL_BOE_TV101WUM_NL6
 	  Say Y here if you want to support for BOE TV101WUM and AUO KD101N80
 	  45NA WUXGA PANEL DSI Video Mode panel
 
+config DRM_PANEL_DDIC_CH13726A
+	tristate "DDIC CH13726A-based DSI panel"
+	depends on OF
+	//
+	//
+	select DRM_DISPLAY_DP_HELPER
+	select DRM_DISPLAY_HELPER
+	help
+	  Say Y here if you want to enable support for DDIC CH13726A-based
+	  display panels.
+
 config DRM_PANEL_EBBG_FT8719
 	tristate "EBBG FT8719 panel driver"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 5581387707c62f..239a1049fb89ef 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_DRM_PANEL_BOE_BF060Y8M_AJ0) += panel-boe-bf060y8m-aj0.o
 obj-$(CONFIG_DRM_PANEL_BOE_HIMAX8279D) += panel-boe-himax8279d.o
 obj-$(CONFIG_DRM_PANEL_BOE_TH101MB31UIG002_28A) += panel-boe-th101mb31ig002-28a.o
 obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
+obj-$(CONFIG_DRM_PANEL_DDIC_CH13726A) += panel-ddic-ch13726a.o
 obj-$(CONFIG_DRM_PANEL_DSI_CM) += panel-dsi-cm.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
diff --git a/drivers/gpu/drm/panel/panel-ddic-ch13726a.c b/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
new file mode 100644
index 00000000000000..3d4c0d36077dfe
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
@@ -0,0 +1,325 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * DDIC CH13726A MIPI-DSI panel driver
+ * Copyright (c) 2024, Teguh Sobirin <teguh@sobir.in>.
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/display/drm_dsc.h>
+#include <drm/display/drm_dsc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+struct ch13726a_panel {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct drm_dsc_config dsc;
+	struct regulator_bulk_data supplies[4];
+	struct gpio_desc *reset_gpio;
+	enum drm_panel_orientation orientation;
+	bool prepared;
+};
+
+static inline struct ch13726a_panel *to_ch13726a_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct ch13726a_panel, panel);
+}
+
+static void ch13726a_reset(struct ch13726a_panel *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+}
+
+static int ch13726a_on(struct ch13726a_panel *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int ch13726a_disable(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	msleep(100);
+
+	return 0;
+}
+
+static int ch13726a_prepare(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ch13726a_reset(ctx);
+
+	ret = ch13726a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	msleep(28);
+
+	ctx->prepared = true;
+
+	return 0;
+}
+
+static int ch13726a_unprepare(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+
+	if (!ctx->prepared)
+		return 0;
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode ch13726a_mode = {
+	.clock = (960 + 28 + 4 + 36) * (1280 + 16 + 4 + 8) * 60 / 1000,
+	.hdisplay = 960,
+	.hsync_start = 960 + 28,
+	.hsync_end = 960 + 28 + 4,
+	.htotal = 960 + 28 + 4 + 36,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 16,
+	.vsync_end = 1280 + 16 + 4,
+	.vtotal = 1280 + 16 + 4 + 8,
+	.width_mm = 65,
+	.height_mm = 75,
+};
+
+static int ch13726a_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &ch13726a_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static enum drm_panel_orientation ch13726a_get_orientation(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+
+	return ctx->orientation;
+}
+
+static const struct drm_panel_funcs ch13726a_panel_funcs = {
+	.prepare = ch13726a_prepare,
+	.unprepare = ch13726a_unprepare,
+	.disable = ch13726a_disable,
+	.get_modes = ch13726a_get_modes,
+	.get_orientation = ch13726a_get_orientation,
+};
+
+static int ch13726a_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops ch13726a_bl_ops = {
+	.update_status = ch13726a_bl_update_status,
+};
+
+static struct backlight_device *
+ch13726a_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &ch13726a_bl_ops, &props);
+}
+
+static int ch13726a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ch13726a_panel *ctx;
+	int rotation;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd1v2";
+	ctx->supplies[1].supply = "vddio";
+	ctx->supplies[2].supply = "vdd";
+	ctx->supplies[3].supply = "avdd";
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ret = of_property_read_u32(dev->of_node, "rotation", &rotation);
+	if (ret == -EINVAL) {
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
+	}
+
+	if (rotation == 0)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_NORMAL;
+	else if (rotation == 90)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_RIGHT_UP;
+	else if (rotation == 180)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;
+	else if (rotation == 270)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_LEFT_UP;
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &ch13726a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = ch13726a_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ch13726a_remove(struct mipi_dsi_device *dsi)
+{
+	struct ch13726a_panel *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ch13726a_of_match[] = {
+	{ .compatible = "ddic,ch13726a" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ch13726a_of_match);
+
+static struct mipi_dsi_driver ch13726a_driver = {
+	.probe = ch13726a_probe,
+	.remove = ch13726a_remove,
+	.driver = {
+		.name = "panel-ch13726a-amoled",
+		.of_match_table = ch13726a_of_match,
+	},
+};
+module_mipi_dsi_driver(ch13726a_driver);
+
+MODULE_DESCRIPTION("DRM driver for CH13726A DSI panels");
+MODULE_LICENSE("GPL");

From 358d60900e2cae0975d0cbc3bed60c86772694ab Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:19:59 +0800
Subject: [PATCH 06/11] Input: driver for AYN Odin2 Gamepad

---
 drivers/input/joystick/Kconfig  |   4 +
 drivers/input/joystick/Makefile |   1 +
 drivers/input/joystick/odin2.c  | 259 ++++++++++++++++++++++++++++++++
 3 files changed, 264 insertions(+)
 create mode 100644 drivers/input/joystick/odin2.c

diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index 7755e5b454d2cb..031b7428068a8c 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -344,6 +344,10 @@ config JOYSTICK_MAPLE
 	  To compile this as a module choose M here: the module will be called
 	  maplecontrol.
 
+config JOYSTICK_ODIN2
+	tristate "AYN Odin2 gamepad"
+	depends on SERIAL_DEV_BUS
+
 config JOYSTICK_PSXPAD_SPI
 	tristate "PlayStation 1/2 joypads via SPI interface"
 	depends on SPI
diff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile
index 9976f596a92085..ba7d72514c8b97 100644
--- a/drivers/input/joystick/Makefile
+++ b/drivers/input/joystick/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_JOYSTICK_JOYDUMP)		+= joydump.o
 obj-$(CONFIG_JOYSTICK_MAGELLAN)		+= magellan.o
 obj-$(CONFIG_JOYSTICK_MAPLE)		+= maplecontrol.o
 obj-$(CONFIG_JOYSTICK_N64)		+= n64joy.o
+obj-$(CONFIG_JOYSTICK_ODIN2)		+= odin2.o
 obj-$(CONFIG_JOYSTICK_PSXPAD_SPI)	+= psxpad-spi.o
 obj-$(CONFIG_JOYSTICK_PXRC)		+= pxrc.o
 obj-$(CONFIG_JOYSTICK_QWIIC)		+= qwiic-joystick.o
diff --git a/drivers/input/joystick/odin2.c b/drivers/input/joystick/odin2.c
new file mode 100644
index 00000000000000..1350fc1a291b4f
--- /dev/null
+++ b/drivers/input/joystick/odin2.c
@@ -0,0 +1,259 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Ayn Odin 2 Gamepad
+ *
+ * Copyright (C) 2024 Molly Sophia <mollysophia379@gmail.com>
+ * Copyright (C) 2024 BigfootACA <bigfoot@classfun.cn>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/gpio/consumer.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/serdev.h>
+#include <linux/slab.h>
+#include <uapi/linux/sched/types.h>
+
+#define MAX_DATA_LEN 64
+
+#define gamepad_serdev_write_seq(serdev, seq...)                              \
+	do {                                                                  \
+		static const u8 d[] = { seq };                                \
+		struct device *dev = &serdev->dev;                            \
+		int ret;                                                      \
+		ret = serdev_device_write_buf(serdev, d, ARRAY_SIZE(d));      \
+		if (ret < 0 || ret < ARRAY_SIZE(d)) {                         \
+			dev_warn_ratelimited(dev, "Unable to write data: %d", \
+					     ret);                            \
+			return;                                               \
+		}                                                             \
+	} while (0)
+
+static const unsigned int keymap[] = {
+	BTN_DPAD_UP, BTN_DPAD_DOWN, BTN_DPAD_LEFT, BTN_DPAD_RIGHT,
+	BTN_NORTH,   BTN_WEST,	    BTN_EAST,	   BTN_SOUTH,
+	BTN_TL,	     BTN_TR,	    BTN_SELECT,	   BTN_START,
+	BTN_THUMBL,  BTN_THUMBR,    BTN_MODE,	   BTN_BACK
+};
+
+struct gamepad_data {
+	u8 header[4];
+	u8 frame_number;
+	u8 command;
+	u16 data_len;
+	u8 data[MAX_DATA_LEN];
+};
+
+struct gamepad_device {
+	struct device *dev;
+	struct gpio_desc *en_gpio;
+	struct input_dev *dev_input;
+};
+
+static u8 gamepad_data_checksum(const u8 *data, size_t count)
+{
+	const u8 *ptr = data;
+	u8 ret = data[4];
+
+	for (int i = 5; i < count - 1; i++)
+		ret ^= ptr[i];
+
+	return ret;
+}
+
+static void gamepad_send_init_sequence(struct serdev_device *serdev)
+{
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x0, 0x1, 0x2,
+				 0x0, 0x7, 0x1, 0x5);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x1, 0x1, 0x1,
+				 0x0, 0x6, 0x7);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x2, 0x1, 0x1, 0x0, 0x2, 0x0);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xa5, 0xd3, 0x5a, 0x3d, 0x3, 0x01,
+				 0x0a, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x28,
+				 0x00, 0x00, 0x00, 0x07, 0x23);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x4, 0x1, 0x1,
+				 0x0, 0x6, 0x2);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x5, 0x1, 0x1,
+				 0x0, 0x2, 0x7);
+	msleep(100);
+}
+
+static void gamepad_input_handler(struct gamepad_device *dev,
+				  struct gamepad_data *data)
+{
+	static unsigned long prev_states;
+	unsigned long keys = data->data[0] | (data->data[1] << 8);
+	unsigned long current_states = keys, changes;
+	int i;
+	struct input_dev *indev;
+
+	indev = dev->dev_input;
+	if (!indev)
+		return;
+
+	bitmap_xor(&changes, &current_states, &prev_states, ARRAY_SIZE(keymap));
+
+	for_each_set_bit(i, &changes, ARRAY_SIZE(keymap)) {
+		input_report_key(indev, keymap[i], (current_states & BIT(i)));
+	}
+
+	input_report_abs(indev, ABS_HAT2X,
+			 0x755 - (data->data[2] | (data->data[3] << 8)));
+	input_report_abs(indev, ABS_HAT2Y,
+			 0x755 - (data->data[4] | (data->data[5] << 8)));
+	input_report_abs(indev, ABS_X,
+			 -(int16_t)(data->data[6] | (data->data[7] << 8)));
+	input_report_abs(indev, ABS_Y,
+			 -(int16_t)(data->data[8] | (data->data[9] << 8)));
+	input_report_abs(indev, ABS_RX,
+			 -(int16_t)(data->data[10] | (data->data[11] << 8)));
+	input_report_abs(indev, ABS_RY,
+			 -(int16_t)(data->data[12] | (data->data[13] << 8)));
+
+	input_sync(indev);
+	prev_states = keys;
+}
+
+static void gamepad_data_handler(struct serdev_device *serdev,
+				 struct gamepad_data *data)
+{
+	struct gamepad_device *dev = serdev_device_get_drvdata(serdev);
+
+	switch (data->command) {
+	case 0x2:
+		gamepad_input_handler(dev, data);
+		break;
+	default:
+		break;
+	}
+}
+
+static size_t gamepad_mcu_uart_rx_bytes(struct serdev_device *serdev,
+					const u8 *data, size_t count)
+{
+	struct device *dev = &serdev->dev;
+	struct gamepad_data recv_data_buffer;
+	u8 checksum;
+
+	if (!data || count < 7) {
+		dev_warn_ratelimited(dev, "invalid packet");
+		return count;
+	}
+
+	checksum = gamepad_data_checksum(data, count);
+	if (checksum != *(data + count - 1)) {
+		dev_warn_ratelimited(dev, "packet checksum failed");
+		return count;
+	}
+
+	memcpy(recv_data_buffer.header, data, 4);
+	recv_data_buffer.frame_number = *(data + 4);
+	recv_data_buffer.command = *(data + 5);
+	recv_data_buffer.data_len = *(data + 6) | (*(data + 7) << 8);
+
+	if (recv_data_buffer.data_len) {
+		memset(&recv_data_buffer.data[0], 0,
+		       sizeof(recv_data_buffer.data));
+		memcpy(&recv_data_buffer.data[0], data + 8,
+		       recv_data_buffer.data_len);
+	}
+
+	gamepad_data_handler(serdev, &recv_data_buffer);
+	return count;
+}
+
+static const struct serdev_device_ops gamepad_mcu_uart_client_ops = {
+	.receive_buf = gamepad_mcu_uart_rx_bytes,
+};
+
+static int gamepad_mcu_uart_probe(struct serdev_device *serdev)
+{
+	struct device *dev = &serdev->dev;
+	struct gamepad_device *gamepad_dev;
+	int ret;
+
+	gamepad_dev = devm_kzalloc(dev, sizeof(*gamepad_dev), GFP_KERNEL);
+	if (!gamepad_dev)
+		return dev_err_probe(dev, -ENOMEM, "could not allocate memory for device data\n");
+
+	gamepad_dev->en_gpio =
+		devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(gamepad_dev->en_gpio)) {
+		ret = PTR_ERR(gamepad_dev->en_gpio);
+		return dev_err_probe(dev, ret, "Unable to get enable gpio\n");
+	}
+
+	ret = devm_serdev_device_open(dev, serdev);
+	if (ret)
+		return dev_err_probe(dev, ret, "Unable to open UART device\n");
+	gamepad_dev->dev = dev;
+
+	serdev_device_set_drvdata(serdev, gamepad_dev);
+
+	ret = serdev_device_set_baudrate(serdev, 115200);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to set up host baud rate\n");
+
+	serdev_device_set_flow_control(serdev, false);
+
+	gamepad_dev->dev_input = devm_input_allocate_device(dev);
+	if (!gamepad_dev->dev_input)
+		return dev_err_probe(dev, -ENOMEM, "Not enough memory for input device\n");
+
+	gamepad_dev->dev_input->name = "Ayn Odin2 Gamepad";
+	gamepad_dev->dev_input->phys = "odin2-gamepad/input0";
+	__set_bit(EV_ABS, gamepad_dev->dev_input->evbit);
+
+	for (int i = 0; i < ARRAY_SIZE(keymap); i++)
+		input_set_capability(gamepad_dev->dev_input, EV_KEY, keymap[i]);
+
+	input_set_capability(gamepad_dev->dev_input, EV_KEY, BTN_JOYSTICK);
+
+	for (int i = ABS_X; i <= ABS_RZ; i++)
+		input_set_abs_params(gamepad_dev->dev_input, i, -0x580, 0x580,
+				     0, 0);
+
+	input_set_abs_params(gamepad_dev->dev_input, ABS_HAT2X, 0, 1830, 0, 30);
+	input_set_abs_params(gamepad_dev->dev_input, ABS_HAT2Y, 0, 1830, 0, 30);
+
+	ret = input_register_device(gamepad_dev->dev_input);
+	if (ret)
+		return dev_err_probe(dev, ret, "Could not register input device\n");
+
+	serdev_device_set_client_ops(serdev, &gamepad_mcu_uart_client_ops);
+
+	gamepad_send_init_sequence(serdev);
+
+	return 0;
+}
+
+static const struct of_device_id gamepad_mcu_uart_of_match[] = {
+	{ .compatible = "ayn,odin2-gamepad" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, gamepad_mcu_uart_of_match);
+
+static struct serdev_device_driver gamepad_mcu_uart_driver = {
+	.driver = {
+		.name = "odin2-gamepad",
+		.of_match_table = gamepad_mcu_uart_of_match,
+	},
+	.probe = gamepad_mcu_uart_probe,
+};
+
+module_serdev_device_driver(gamepad_mcu_uart_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Gamepad driver for Ayn Odin2");
+MODULE_AUTHOR("Molly Sophia <mollysophia379@gmail.com>");
+MODULE_AUTHOR("BigfootACA <bigfoot@classfun.cn>");

From a6347fe2649416d49c45e70d822c94d52bdf3e40 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 30 Sep 2024 14:42:38 +0700
Subject: [PATCH 07/11] power: supply: Driver for Qualcomm SMB5

---
 drivers/power/supply/Kconfig                |   9 +
 drivers/power/supply/Makefile               |   1 +
 drivers/power/supply/qcom_pm8150b_charger.c | 945 ++++++++++++++++++++
 3 files changed, 955 insertions(+)
 create mode 100644 drivers/power/supply/qcom_pm8150b_charger.c

diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index bcfa63fb9f1e20..ec3f3d5b20c8f2 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -1008,6 +1008,15 @@ config CHARGER_QCOM_SMB2
 	  adds support for the SMB2 switch mode battery charger found
 	  in PMI8998 and related PMICs.
 
+config CHARGER_QCOM_SMB5
+	tristate "Qualcomm PMI8998 PMIC charger driver"
+	depends on MFD_SPMI_PMIC
+	depends on IIO
+	help
+	  Say Y here to enable the Qualcomm PMIC Charger driver. This
+	  adds support for the SMB5 switch mode battery charger found
+	  in PM8150B and related PMICs.
+
 config FUEL_GAUGE_MM8013
 	tristate "Mitsumi MM8013 fuel gauge driver"
 	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 8dcb4154531718..9237f62701582d 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -116,4 +116,5 @@ obj-$(CONFIG_BATTERY_SURFACE)	+= surface_battery.o
 obj-$(CONFIG_CHARGER_SURFACE)	+= surface_charger.o
 obj-$(CONFIG_BATTERY_UG3105)	+= ug3105_battery.o
 obj-$(CONFIG_CHARGER_QCOM_SMB2)	+= qcom_pmi8998_charger.o
+obj-$(CONFIG_CHARGER_QCOM_SMB5)	+= qcom_pm8150b_charger.o
 obj-$(CONFIG_FUEL_GAUGE_MM8013)	+= mm8013.o
diff --git a/drivers/power/supply/qcom_pm8150b_charger.c b/drivers/power/supply/qcom_pm8150b_charger.c
new file mode 100644
index 00000000000000..48791e145345d9
--- /dev/null
+++ b/drivers/power/supply/qcom_pm8150b_charger.c
@@ -0,0 +1,945 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024, Teguh Sobirin <teguh@sobir.in>.
+ *
+ * This driver is for the switch-mode battery charger power delivery
+ * and boost hardware found in pm8150b and related PMICs.
+ * This work based on pmi8998 charger driver by 
+ * Caleb Connolly <caleb.connolly@linaro.org>
+ * Should be merged with the existing charger driver in the future.
+ */
+
+#include <linux/bits.h>
+#include <linux/devm-helpers.h>
+#include <linux/iio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/minmax.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/of.h>
+#include <linux/power_supply.h>
+#include <linux/regmap.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
+/* clang-format off */
+#define BATTERY_CHARGER_STATUS_1			0x06
+#define ICL_INCR_REQ_FOR_PRECHG_BIT			BIT(7)
+#define ZERO_CHARGE_CURRENT_BIT				BIT(6)
+#define STEP_CHARGING_STATUS_SHIFT			3
+#define STEP_CHARGING_STATUS_MASK			GENMASK(5, 3)
+#define BATTERY_CHARGER_STATUS_MASK			GENMASK(2, 0)
+
+#define BATTERY_CHARGER_STATUS_2			0x07
+#define DROP_IN_BATTERY_VOLTAGE_REFERENCE_BIT		BIT(7)
+#define VBATT_LTET_RECHARGE_BIT				BIT(6)
+#define VBATT_GTET_INHIBIT_BIT				BIT(5)
+#define VBATT_GTET_FLOAT_VOLTAGE_BIT			BIT(4)
+#define BATT_GT_FULL_ON_BIT				BIT(3)
+#define CHARGER_ERROR_STATUS_SFT_EXPIRE_BIT		BIT(2)
+#define CHARGER_ERROR_STATUS_BAT_OV_BIT			BIT(1)
+#define CHARGER_ERROR_STATUS_BAT_TERM_MISSING_BIT	BIT(0)
+
+#define BATTERY_CHARGER_STATUS_4		0x0A
+#define CHARGE_CURRENT_REFERENCE_MASK		GENMASK(7, 0)
+
+#define BATTERY_CHARGER_STATUS_7_REG		0x0D
+#define BAT_TEMP_STATUS_SOFT_LIMIT_MASK		GENMASK(5, 4)
+#define BAT_TEMP_STATUS_HOT_SOFT_BIT		BIT(5)
+#define BAT_TEMP_STATUS_COLD_SOFT_BIT		BIT(4)
+#define BAT_TEMP_STATUS_HARD_LIMIT_MASK		GENMASK(3, 2)
+#define BAT_TEMP_STATUS_TOO_HOT_BIT		BIT(3)
+#define BAT_TEMP_STATUS_TOO_COLD_BIT		BIT(2)
+#define BAT_TEMP_STATUS_TOO_HOT_AFP_BIT		BIT(1)
+#define BAT_TEMP_STATUS_TOO_COLD_AFP_BIT	BIT(0)
+
+#define CHARGING_ENABLE_CMD			0x42
+#define CHARGING_ENABLE_CMD_BIT			BIT(0)
+#define CHARGING_ENABLE_POF_BIT			BIT(1)
+
+#define CHGR_CFG2				0x51
+#define EN_FAVOR_IN_BIT				BIT(5)
+#define BAT_OV_ECC_BIT				BIT(4)
+#define I_TERM_BIT				BIT(3)
+#define AUTO_RECHG_BIT				BIT(2)
+#define SOC_BASED_RECHG_BIT			BIT(1)
+#define CHARGER_INHIBIT_BIT			BIT(0)
+
+#define PRE_CHARGE_CURRENT_CFG			0x60
+#define PRE_CHARGE_CURRENT_SETTING_MASK		GENMASK(2, 0)
+
+#define FAST_CHARGE_CURRENT_CFG			0x61
+#define FAST_CHARGE_CURRENT_SETTING_MASK	GENMASK(7, 0)
+
+#define FLOAT_VOLTAGE_CFG			0x70
+#define FLOAT_VOLTAGE_SETTING_MASK		GENMASK(7, 0)
+
+#define CHARGE_RCHG_SOC_THRESHOLD_CFG_REG	0x7D
+#define CHARGE_RCHG_SOC_THRESHOLD_CFG_MASK	GENMASK(7, 0)
+
+#define ICL_STATUS				0x107
+#define ICL_INPUT_CURRENT_LIMIT_MASK		GENMASK(7, 0)
+
+#define AICL_STATUS				0x108
+#define AICL_INPUT_CURRENT_LIMIT_MASK		GENMASK(7, 0)
+
+#define POWER_PATH_STATUS				0x10B
+#define P_PATH_INPUT_SS_DONE_BIT			BIT(7)
+#define P_PATH_USBIN_SUSPEND_STS_BIT			BIT(6)
+#define P_PATH_DCIN_SUSPEND_STS_BIT			BIT(5)
+#define P_PATH_USE_USBIN_BIT				BIT(4)
+#define P_PATH_USE_DCIN_BIT				BIT(3)
+#define P_PATH_POWER_PATH_MASK				GENMASK(2, 1)
+#define P_PATH_VALID_INPUT_POWER_SOURCE_STS_BIT		BIT(0)
+
+#define OTG_CFG					0x153
+#define OTG_RESERVED_BIT			BIT(7)
+#define FAST_ROLE_SWAP_START_OPTION_BIT		BIT(6)
+#define DIS_OTG_ON_TSD_BIT			BIT(5)
+#define OTG_CFG_4_BIT				BIT(4)
+#define EN_SOC_BASED_OTG_UVLO_BIT		BIT(3)
+#define ENABLE_OTG_IN_DEBUG_MODE_BIT		BIT(2)
+#define OTG_EN_SRC_CFG_BIT			BIT(1)
+#define OTG_HICCUP_CNTR_RST_TIMER_SEL_BIT	BIT(0)
+
+#define APSD_STATUS				0x307
+#define APSD_STATUS_7_BIT			BIT(7)
+#define HVDCP_CHECK_TIMEOUT_BIT			BIT(6)
+#define SLOW_PLUGIN_TIMEOUT_BIT			BIT(5)
+#define ENUMERATION_DONE_BIT			BIT(4)
+#define VADP_CHANGE_DONE_AFTER_AUTH_BIT		BIT(3)
+#define QC_AUTH_DONE_STATUS_BIT			BIT(2)
+#define QC_CHARGER_BIT				BIT(1)
+#define APSD_DTC_STATUS_DONE_BIT		BIT(0)
+
+#define APSD_RESULT_STATUS			0x308
+#define APSD_RESULT_STATUS_7_BIT		BIT(7)
+#define APSD_RESULT_STATUS_MASK			GENMASK(6, 0)
+#define QC_3P0_BIT				BIT(6)
+#define QC_2P0_BIT				BIT(5)
+#define FLOAT_CHARGER_BIT			BIT(4)
+#define DCP_CHARGER_BIT				BIT(3)
+#define CDP_CHARGER_BIT				BIT(2)
+#define OCP_CHARGER_BIT				BIT(1)
+#define SDP_CHARGER_BIT				BIT(0)
+
+#define USBIN_INT_RT_STS_OFFSET			0x310
+#define USBIN_PLUGIN_RT_STS_BIT			BIT(4)
+
+#define USBIN_CMD_IL				0x340
+#define USBIN_SUSPEND_BIT			BIT(0)
+
+#define CMD_APSD				0x341
+#define APSD_RERUN_BIT				BIT(0)
+
+#define CMD_ICL_OVERRIDE			0x342
+#define ICL_OVERRIDE_BIT			BIT(0)
+
+#define TYPE_C_CFG				0x358
+#define BC1P2_START_ON_CC_BIT			BIT(7)
+
+#define HVDCP_PULSE_COUNT_MAX			0x35b
+#define HVDCP_PULSE_COUNT_MAX_QC2_MASK		GENMASK(7, 6)
+
+#define USBIN_ADAPTER_ALLOW_CFG			0x360
+#define USBIN_ADAPTER_ALLOW_MASK		GENMASK(3, 0)
+
+#define USBIN_OPTIONS_1_CFG			0x362
+#define HVDCP_AUTH_ALG_EN_CFG_BIT		BIT(6)
+#define HVDCP_AUTONOMOUS_MODE_EN_CFG_BIT	BIT(5)
+#define BC1P2_SRC_DETECT_BIT			BIT(3)
+#define HVDCP_EN_BIT				BIT(2)
+#define HVDCP_NO_AUTH_QC3_CFG_BIT		BIT(1)
+
+#define USBIN_LOAD_CFG				0x365
+#define ICL_OVERRIDE_AFTER_APSD_BIT		BIT(4)
+#define USBIN_AICL_STEP_TIMING_SEL_MASK		GENMASK(3, 2)
+#define USBIN_IN_COLLAPSE_GF_SEL_MASK		GENMASK(1, 0)
+
+#define USBIN_ICL_OPTIONS			0x366
+#define CFG_USB3P0_SEL_BIT			BIT(2)
+#define USB51_MODE_BIT				BIT(1)
+#define USBIN_MODE_CHG_BIT			BIT(0)
+
+#define USBIN_CURRENT_LIMIT_CFG			0x370
+#define USBIN_CURRENT_LIMIT_MASK		GENMASK(7, 0)
+
+#define USBIN_AICL_OPTIONS_CFG			0x380
+#define SUSPEND_ON_COLLAPSE_USBIN_BIT		BIT(7)
+#define USBIN_AICL_PERIODIC_RERUN_EN_BIT	BIT(4)
+#define USBIN_AICL_ADC_EN_BIT			BIT(3)
+#define USBIN_AICL_EN_BIT			BIT(2)
+
+#define USBIN_5V_AICL_THRESHOLD_CFG		0x381
+#define USBIN_5V_AICL_THRESHOLD_CFG_MASK	GENMASK(2, 0)
+
+#define USBIN_CONT_AICL_THRESHOLD_CFG		0x384
+#define USBIN_CONT_AICL_THRESHOLD_CFG_MASK	GENMASK(5, 0)
+
+#define DCIN_CMD_IL				0x440
+#define DCIN_SUSPEND_BIT			BIT(0)
+
+#define TYPE_C_SNK_STATUS			0x506
+#define DETECTED_SRC_TYPE_MASK			GENMASK(6, 0)
+#define SNK_RP_STD_DAM_BIT			BIT(6)
+#define SNK_RP_1P5_DAM_BIT			BIT(5)
+#define SNK_RP_3P0_DAM_BIT			BIT(4)
+#define SNK_DAM_MASK				GENMASK(6, 4)
+#define SNK_DAM_500MA_BIT			BIT(6)
+#define SNK_DAM_1500MA_BIT			BIT(5)
+#define SNK_DAM_3000MA_BIT			BIT(4)
+#define SNK_RP_STD_BIT				BIT(3)
+#define SNK_RP_1P5_BIT				BIT(2)
+#define SNK_RP_3P0_BIT				BIT(1)
+#define SNK_RP_SHORT_BIT			BIT(0)
+
+#define TYPE_C_MODE_CFG				0x544
+#define TYPEC_TRY_MODE_MASK			GENMASK(4, 3)
+#define EN_TRY_SNK_BIT				BIT(4)
+#define EN_TRY_SRC_BIT				BIT(3)
+#define TYPEC_POWER_ROLE_CMD_MASK		GENMASK(2, 0)
+#define EN_SRC_ONLY_BIT				BIT(2)
+#define EN_SNK_ONLY_BIT				BIT(1)
+#define TYPEC_DISABLE_CMD_BIT			BIT(0)
+
+#define TYPEC_TYPE_C_VCONN_CONTROL		0x546
+#define VCONN_EN_ORIENTATION_BIT		BIT(2)
+#define VCONN_EN_VALUE_BIT			BIT(1)
+#define VCONN_EN_SRC_BIT			BIT(0)
+
+#define TYPE_C_DEBUG_ACCESS_SINK		0x54a
+#define TYPEC_DEBUG_ACCESS_SINK_MASK		GENMASK(4, 0)
+
+#define DEBUG_ACCESS_SRC_CFG			0x54C
+#define EN_UNORIENTED_DEBUG_ACCESS_SRC_BIT	BIT(0)
+
+#define TYPE_C_EXIT_STATE_CFG			0x550
+#define BYPASS_VSAFE0V_DURING_ROLE_SWAP_BIT	BIT(3)
+#define SEL_SRC_UPPER_REF_BIT			BIT(2)
+#define EXIT_SNK_BASED_ON_CC_BIT		BIT(0)
+
+#define TYPE_C_INTERRUPT_EN_CFG_1			0x55e
+#define TYPEC_LEGACY_CABLE_INT_EN_BIT			BIT(7)
+#define TYPEC_NONCOMPLIANT_LEGACY_CABLE_INT_EN_BIT	BIT(6)
+#define TYPEC_TRYSOURCE_DETECT_INT_EN_BIT		BIT(5)
+#define TYPEC_TRYSINK_DETECT_INT_EN_BIT			BIT(4)
+#define TYPEC_CCOUT_DETACH_INT_EN_BIT			BIT(3)
+#define TYPEC_CCOUT_ATTACH_INT_EN_BIT			BIT(2)
+#define TYPEC_VBUS_DEASSERT_INT_EN_BIT			BIT(1)
+#define TYPEC_VBUS_ASSERT_INT_EN_BIT			BIT(0)
+
+#define BARK_BITE_WDOG_PET			0x643
+#define BARK_BITE_WDOG_PET_BIT			BIT(0)
+
+#define WD_CFG					0x651
+#define WATCHDOG_TRIGGER_AFP_EN_BIT		BIT(7)
+#define BARK_WDOG_INT_EN_BIT			BIT(6)
+#define BITE_WDOG_INT_EN_BIT			BIT(5)
+#define SFT_AFTER_WDOG_IRQ_MASK			GENMASK(4, 3)
+#define WDOG_IRQ_SFT_BIT			BIT(2)
+#define WDOG_TIMER_EN_ON_PLUGIN_BIT		BIT(1)
+#define WDOG_TIMER_EN_BIT			BIT(0)
+
+#define SNARL_BARK_BITE_WD_CFG			0x653
+#define BITE_WDOG_DISABLE_CHARGING_CFG_BIT	BIT(7)
+#define SNARL_WDOG_TIMEOUT_MASK			GENMASK(6, 4)
+#define BARK_WDOG_TIMEOUT_MASK			GENMASK(3, 2)
+#define BITE_WDOG_TIMEOUT_MASK			GENMASK(1, 0)
+
+#define AICL_RERUN_TIME_CFG			0x661
+#define AICL_RERUN_TIME_MASK			GENMASK(1, 0)
+
+#define SDP_CURRENT_UA			500000
+#define CDP_CURRENT_UA			3000000
+#define DCP_CURRENT_UA			3300000
+#define CURRENT_MAX_UA			DCP_CURRENT_UA
+
+/* pmi8150b registers represent current in increments of 1/40th of an amp */
+#define CURRENT_SCALE_FACTOR		50000
+/* clang-format on */
+
+enum charger_status {
+	TRICKLE_CHARGE = 0,
+	PRE_CHARGE,
+	FAST_CHARGE,
+	FULLON_CHARGE,
+	TAPER_CHARGE,
+	TERMINATE_CHARGE,
+	INHIBIT_CHARGE,
+	DISABLE_CHARGE,
+};
+
+struct smb5_register {
+	u16 addr;
+	u8 mask;
+	u8 val;
+};
+
+/**
+ * struct smb5_chip - smb5 chip structure
+ * @dev:		Device reference for power_supply
+ * @name:		The platform device name
+ * @base:		Base address for smb5 registers
+ * @regmap:		Register map
+ * @batt_info:		Battery data from DT
+ * @status_change_work: Worker to handle plug/unplug events
+ * @cable_irq:		USB plugin IRQ
+ * @wakeup_enabled:	If the cable IRQ will cause a wakeup
+ * @usb_in_i_chan:	USB_IN current measurement channel
+ * @usb_in_v_chan:	USB_IN voltage measurement channel
+ * @chg_psy:		Charger power supply instance
+ */
+struct smb5_chip {
+	struct device *dev;
+	const char *name;
+	unsigned int base;
+	struct regmap *regmap;
+	struct power_supply_battery_info *batt_info;
+
+	struct delayed_work status_change_work;
+	int cable_irq;
+	bool wakeup_enabled;
+
+	struct iio_channel *usb_in_i_chan;
+	struct iio_channel *usb_in_v_chan;
+
+	struct power_supply *chg_psy;
+};
+
+static enum power_supply_property smb5_properties[] = {
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_USB_TYPE,
+};
+
+static enum power_supply_usb_type smb5_usb_types[] = {
+	POWER_SUPPLY_USB_TYPE_UNKNOWN,
+	POWER_SUPPLY_USB_TYPE_SDP,
+	POWER_SUPPLY_USB_TYPE_DCP,
+	POWER_SUPPLY_USB_TYPE_CDP,
+};
+
+static int smb5_get_prop_usb_online(struct smb5_chip *chip, int *val)
+{
+	unsigned int stat;
+	int rc;
+
+	rc = regmap_read(chip->regmap, chip->base + USBIN_INT_RT_STS_OFFSET, &stat);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read USBIN_RT_STS rc=%d\n", rc);
+		return rc;
+	}
+
+	*val = (stat & USBIN_PLUGIN_RT_STS_BIT);
+	return 0;
+}
+
+/*
+ * Qualcomm "automatic power source detection" aka APSD
+ * tells us what type of charger we're connected to.
+ */
+static int smb5_apsd_get_charger_type(struct smb5_chip *chip, int *val)
+{
+	unsigned int apsd_stat, stat;
+	int usb_online = 0;
+	int rc;
+
+	rc = smb5_get_prop_usb_online(chip, &usb_online);
+	if (!usb_online) {
+		*val = POWER_SUPPLY_USB_TYPE_UNKNOWN;
+		return rc;
+	}
+
+	rc = regmap_read(chip->regmap, chip->base + APSD_STATUS, &apsd_stat);
+	if (rc < 0) {
+		dev_err(chip->dev, "Failed to read apsd status, rc = %d", rc);
+		return rc;
+	}
+	if (!(apsd_stat & APSD_DTC_STATUS_DONE_BIT)) {
+		dev_err(chip->dev, "Apsd not ready");
+		return -EAGAIN;
+	}
+
+	rc = regmap_read(chip->regmap, chip->base + APSD_RESULT_STATUS, &stat);
+	if (rc < 0) {
+		dev_err(chip->dev, "Failed to read apsd result, rc = %d", rc);
+		return rc;
+	}
+
+	stat &= APSD_RESULT_STATUS_MASK;
+
+	if (stat & CDP_CHARGER_BIT){
+		*val = POWER_SUPPLY_USB_TYPE_CDP;
+	} else if (stat & DCP_CHARGER_BIT){
+		*val = POWER_SUPPLY_USB_TYPE_DCP;
+	} else if (stat & OCP_CHARGER_BIT){
+		*val = POWER_SUPPLY_USB_TYPE_DCP;
+	} else if (stat & FLOAT_CHARGER_BIT){
+		*val = POWER_SUPPLY_USB_TYPE_DCP;
+	} else if (stat & QC_2P0_BIT){
+		*val = POWER_SUPPLY_USB_TYPE_DCP;
+	} else if (stat & QC_3P0_BIT){
+		*val = POWER_SUPPLY_USB_TYPE_DCP;
+	} else {
+		*val = POWER_SUPPLY_USB_TYPE_SDP;
+	}
+
+	return 0;
+}
+
+static int smb5_get_prop_status(struct smb5_chip *chip, int *val)
+{
+	unsigned char stat[2];
+	int usb_online = 0;
+	int rc;
+
+	rc = smb5_get_prop_usb_online(chip, &usb_online);
+	if (!usb_online) {
+		*val = POWER_SUPPLY_STATUS_DISCHARGING;
+		return rc;
+	}
+
+	rc = regmap_bulk_read(chip->regmap,
+			      chip->base + BATTERY_CHARGER_STATUS_1, &stat, 2);
+	if (rc < 0) {
+		dev_err(chip->dev, "Failed to read charging status ret=%d\n",
+			rc);
+		return rc;
+	}
+
+	if (stat[1] & VBATT_GTET_INHIBIT_BIT) {
+		*val = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return 0;
+	}
+
+	stat[0] = stat[0] & BATTERY_CHARGER_STATUS_MASK;
+
+	switch (stat[0]) {
+	case TRICKLE_CHARGE:
+	case PRE_CHARGE:
+	case FAST_CHARGE:
+	case FULLON_CHARGE:
+	case TAPER_CHARGE:
+		*val = POWER_SUPPLY_STATUS_CHARGING;
+		return rc;
+	case DISABLE_CHARGE:
+		*val = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return rc;
+	case TERMINATE_CHARGE:
+	case INHIBIT_CHARGE:
+		*val = POWER_SUPPLY_STATUS_FULL;
+		return rc;
+	default:
+		*val = POWER_SUPPLY_STATUS_UNKNOWN;
+		return rc;
+	}
+}
+
+static inline int smb5_get_current_limit(struct smb5_chip *chip,
+					 unsigned int *val)
+{
+	int rc = regmap_read(chip->regmap, chip->base + AICL_STATUS, val);
+
+	if (rc >= 0)
+		*val *= CURRENT_SCALE_FACTOR;	
+	return rc;
+}
+
+static int smb5_set_current_limit(struct smb5_chip *chip, unsigned int val)
+{
+	unsigned char val_raw;
+
+	if (val > 4950000) {
+		dev_err(chip->dev,
+			"Can't set current limit higher than 4950000uA");
+		return -EINVAL;
+	}
+	val_raw = val / CURRENT_SCALE_FACTOR;
+
+	return regmap_write(chip->regmap, chip->base + USBIN_CURRENT_LIMIT_CFG,
+		val_raw);
+}
+
+static void smb5_status_change_work(struct work_struct *work)
+{
+	unsigned int charger_type, current_ua;
+	int usb_online = 0;
+	int count, rc;
+	struct smb5_chip *chip;
+
+	chip = container_of(work, struct smb5_chip, status_change_work.work);
+
+	smb5_get_prop_usb_online(chip, &usb_online);
+	if (!usb_online)
+		return;
+
+	for (count = 0; count < 3; count++) {
+		dev_dbg(chip->dev, "get charger type retry %d\n", count);
+		rc = smb5_apsd_get_charger_type(chip, &charger_type);
+		if (rc != -EAGAIN)
+			break;
+		msleep(100);
+	}
+
+	if (rc < 0 && rc != -EAGAIN) {
+		dev_err(chip->dev, "get charger type failed: %d\n", rc);
+		return;
+	}
+
+	if (rc < 0) {
+		rc = regmap_update_bits(chip->regmap, chip->base + CMD_APSD,
+					APSD_RERUN_BIT, APSD_RERUN_BIT);
+		schedule_delayed_work(&chip->status_change_work,
+				      msecs_to_jiffies(1000));
+		dev_dbg(chip->dev, "get charger type failed, rerun apsd\n");
+		return;
+	}
+
+	switch (charger_type) {
+	case POWER_SUPPLY_USB_TYPE_CDP:
+		current_ua = CDP_CURRENT_UA;
+		break;
+	case POWER_SUPPLY_USB_TYPE_DCP:
+		current_ua = DCP_CURRENT_UA;
+		break;
+	case POWER_SUPPLY_USB_TYPE_SDP:
+	default:
+		current_ua = SDP_CURRENT_UA;
+		break;
+	}
+
+	smb5_set_current_limit(chip, current_ua);
+	power_supply_changed(chip->chg_psy);
+}
+
+static int smb5_get_iio_chan(struct smb5_chip *chip, struct iio_channel *chan,
+			     int *val)
+{
+	int rc;
+	union power_supply_propval status;
+
+	rc = power_supply_get_property(chip->chg_psy, POWER_SUPPLY_PROP_STATUS,
+				       &status);
+	if (rc < 0 || status.intval != POWER_SUPPLY_STATUS_CHARGING) {
+		*val = 0;
+		return 0;
+	}
+
+	if (IS_ERR(chan)) {
+		dev_err(chip->dev, "Failed to chan, err = %li", PTR_ERR(chan));
+		return PTR_ERR(chan);
+	}
+
+	return iio_read_channel_processed(chan, val);
+}
+
+static int smb5_get_prop_health(struct smb5_chip *chip, int *val)
+{
+	int rc;
+	unsigned int stat;
+
+	rc = regmap_read(chip->regmap, chip->base + BATTERY_CHARGER_STATUS_2,
+			 &stat);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read charger status rc=%d\n", rc);
+		return rc;
+	}
+
+	if (stat & CHARGER_ERROR_STATUS_BAT_OV_BIT) {
+		dev_err(chip->dev, "battery over-voltage");
+	}
+
+	rc = regmap_read(chip->regmap, chip->base + BATTERY_CHARGER_STATUS_7_REG,
+			 &stat);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read charger status 7 rc=%d\n", rc);
+		return rc;
+	}
+
+	if (stat & BAT_TEMP_STATUS_TOO_COLD_BIT)
+		*val = POWER_SUPPLY_HEALTH_COLD;
+	else if (stat & BAT_TEMP_STATUS_TOO_HOT_BIT)
+		*val = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (stat & BAT_TEMP_STATUS_COLD_SOFT_BIT)
+		*val = POWER_SUPPLY_HEALTH_COOL;
+	else if (stat & BAT_TEMP_STATUS_HOT_SOFT_BIT)
+		*val = POWER_SUPPLY_HEALTH_WARM;
+	else
+		*val = POWER_SUPPLY_HEALTH_GOOD;
+
+	return 0;
+}
+
+static int smb5_get_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	struct smb5_chip *chip = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		val->strval = "Qualcomm";
+		return 0;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = chip->name;
+		return 0;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return smb5_get_current_limit(chip, &val->intval);
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		return smb5_get_iio_chan(chip, chip->usb_in_i_chan,
+					 &val->intval);
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		return smb5_get_iio_chan(chip, chip->usb_in_v_chan,
+					 &val->intval);
+	case POWER_SUPPLY_PROP_ONLINE:
+		return smb5_get_prop_usb_online(chip, &val->intval);
+	case POWER_SUPPLY_PROP_STATUS:
+		return smb5_get_prop_status(chip, &val->intval);
+	case POWER_SUPPLY_PROP_HEALTH:
+		return smb5_get_prop_health(chip, &val->intval);
+	case POWER_SUPPLY_PROP_USB_TYPE:
+		return smb5_apsd_get_charger_type(chip, &val->intval);
+	default:
+		dev_err(chip->dev, "invalid property: %d\n", psp);
+		return -EINVAL;
+	}
+}
+
+static int smb5_set_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct smb5_chip *chip = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return smb5_set_current_limit(chip, val->intval);
+	default:
+		dev_err(chip->dev, "No setter for property: %d\n", psp);
+		return -EINVAL;
+	}
+}
+
+static int smb5_property_is_writable(struct power_supply *psy,
+				     enum power_supply_property psp)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static irqreturn_t smb5_handle_batt_overvoltage(int irq, void *data)
+{
+	struct smb5_chip *chip = data;
+	unsigned int status;
+
+	regmap_read(chip->regmap, chip->base + BATTERY_CHARGER_STATUS_2,
+		    &status);
+
+	if (status & CHARGER_ERROR_STATUS_BAT_OV_BIT) {
+		/* The hardware stops charging automatically */
+		dev_err(chip->dev, "battery overvoltage detected\n");
+		power_supply_changed(chip->chg_psy);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t smb5_handle_usb_plugin(int irq, void *data)
+{
+	struct smb5_chip *chip = data;
+
+	power_supply_changed(chip->chg_psy);
+
+	schedule_delayed_work(&chip->status_change_work,
+			      msecs_to_jiffies(1500));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t smb5_handle_usb_icl_change(int irq, void *data)
+{
+	struct smb5_chip *chip = data;
+
+	power_supply_changed(chip->chg_psy);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t smb5_handle_wdog_bark(int irq, void *data)
+{
+	struct smb5_chip *chip = data;
+	int rc;
+
+	power_supply_changed(chip->chg_psy);
+
+	rc = regmap_write(chip->regmap, BARK_BITE_WDOG_PET,
+			  BARK_BITE_WDOG_PET_BIT);
+	if (rc < 0)
+		dev_err(chip->dev, "Couldn't pet the dog rc=%d\n", rc);
+
+	return IRQ_HANDLED;
+}
+
+static const struct power_supply_desc smb5_psy_desc = {
+	.name = "pmi8998_charger",
+	.type = POWER_SUPPLY_TYPE_USB,
+	.usb_types = smb5_usb_types,
+	.num_usb_types = ARRAY_SIZE(smb5_usb_types),
+	.properties = smb5_properties,
+	.num_properties = ARRAY_SIZE(smb5_properties),
+	.get_property = smb5_get_property,
+	.set_property = smb5_set_property,
+	.property_is_writeable = smb5_property_is_writable,
+};
+
+/* Init sequence derived from vendor downstream driver */
+static const struct smb5_register smb5_init_seq[] = {
+	{ .addr = USBIN_CMD_IL, .mask = USBIN_SUSPEND_BIT, .val = 0 },
+	{ .addr = AICL_RERUN_TIME_CFG, .mask = AICL_RERUN_TIME_MASK, .val = 0 },
+	/*
+	 * By default configure us as an upstream facing port
+	 * FIXME: This will be handled by the type-c driver
+	 */
+	{ .addr = TYPE_C_MODE_CFG,
+	  .mask = EN_TRY_SNK_BIT | EN_SNK_ONLY_BIT,
+	  .val = EN_TRY_SNK_BIT },
+	{ .addr = TYPEC_TYPE_C_VCONN_CONTROL,
+	  .mask = VCONN_EN_ORIENTATION_BIT | VCONN_EN_SRC_BIT |
+		  VCONN_EN_VALUE_BIT,
+	  .val = VCONN_EN_SRC_BIT },
+	{ .addr = DEBUG_ACCESS_SRC_CFG,
+	  .mask = EN_UNORIENTED_DEBUG_ACCESS_SRC_BIT,
+	  .val = EN_UNORIENTED_DEBUG_ACCESS_SRC_BIT },
+	{ .addr = TYPE_C_EXIT_STATE_CFG,
+	  .mask = SEL_SRC_UPPER_REF_BIT,
+	  .val = SEL_SRC_UPPER_REF_BIT },
+	/*
+	 * Disable Type-C factory mode and stay in Attached.SRC state when VCONN
+	 * over-current happens
+	 */
+	{ .addr = TYPE_C_CFG,
+	  .mask = BC1P2_START_ON_CC_BIT,
+	  .val = 0 },
+	{ .addr = TYPE_C_DEBUG_ACCESS_SINK,
+	  .mask = TYPEC_DEBUG_ACCESS_SINK_MASK,
+	  .val = 0x17 },
+	/* Configure VBUS for software control */
+	{ .addr = OTG_CFG, .mask = OTG_EN_SRC_CFG_BIT, .val = 0 },
+	/*
+	 * Use VBAT to determine the recharge threshold when battery is full
+	 * rather than the state of charge.
+	 */
+	{ .addr = CHARGE_RCHG_SOC_THRESHOLD_CFG_REG,
+	  .mask = CHARGE_RCHG_SOC_THRESHOLD_CFG_MASK,
+	  .val = 98 },
+	/* Enable charging */
+	{ .addr = CHARGING_ENABLE_CMD,
+	  .mask = CHARGING_ENABLE_CMD_BIT,
+	  .val = CHARGING_ENABLE_CMD_BIT },
+	/* Enable BC1P2 Src detect */
+	{ .addr = USBIN_OPTIONS_1_CFG,
+	  .mask = BC1P2_SRC_DETECT_BIT,
+	  .val = BC1P2_SRC_DETECT_BIT },
+	/* Set the default SDP charger type to a 500ma USB 2.0 port */
+	{ .addr = USBIN_ICL_OPTIONS,
+	  .mask = USBIN_MODE_CHG_BIT,
+	  .val = USBIN_MODE_CHG_BIT },
+	{ .addr = CMD_ICL_OVERRIDE,
+	  .mask = ICL_OVERRIDE_BIT,
+	  .val = 0 },
+	{ .addr = USBIN_LOAD_CFG,
+	  .mask = ICL_OVERRIDE_AFTER_APSD_BIT,
+	  .val = 0 },
+	/* Disable watchdog */
+	{ .addr = SNARL_BARK_BITE_WD_CFG, .mask = 0xff, .val = 0 },
+	{ .addr = WD_CFG,
+	  .mask = WATCHDOG_TRIGGER_AFP_EN_BIT | WDOG_TIMER_EN_ON_PLUGIN_BIT |
+		  BARK_WDOG_INT_EN_BIT,
+	  .val = 0 },
+	/*
+	 * Enable Automatic Input Current Limit, this will slowly ramp up the current
+	 * When connected to a wall charger, and automatically stop when it detects
+	 * the charger current limit (voltage drop?) or it reaches the programmed limit.
+	 */
+	{ .addr = USBIN_AICL_OPTIONS_CFG,
+	  .mask = USBIN_AICL_PERIODIC_RERUN_EN_BIT | USBIN_AICL_ADC_EN_BIT
+			| USBIN_AICL_EN_BIT | SUSPEND_ON_COLLAPSE_USBIN_BIT,
+	  .val = USBIN_AICL_PERIODIC_RERUN_EN_BIT | USBIN_AICL_ADC_EN_BIT
+			| USBIN_AICL_EN_BIT | SUSPEND_ON_COLLAPSE_USBIN_BIT },
+};
+
+static int smb5_init_hw(struct smb5_chip *chip)
+{
+	int rc, i;
+	for (i = 0; i < ARRAY_SIZE(smb5_init_seq); i++) {
+		dev_dbg(chip->dev, "%d: Writing 0x%02x to 0x%02x\n", i,
+			smb5_init_seq[i].val, smb5_init_seq[i].addr);
+		rc = regmap_update_bits(chip->regmap,
+					chip->base + smb5_init_seq[i].addr,
+					smb5_init_seq[i].mask,
+					smb5_init_seq[i].val);
+		if (rc < 0)
+			return dev_err_probe(chip->dev, rc,
+					     "%s: init command %d failed\n",
+					     __func__, i);
+	}
+	return 0;
+}
+
+static int smb5_init_irq(struct smb5_chip *chip, int *irq, const char *name,
+			 irqreturn_t (*handler)(int irq, void *data))
+{
+	int irqnum;
+	int rc;
+
+	irqnum = platform_get_irq_byname(to_platform_device(chip->dev), name);
+	if (irqnum < 0)
+		return irqnum;
+
+	rc = devm_request_threaded_irq(chip->dev, irqnum, NULL, handler,
+				       IRQF_ONESHOT, name, chip);
+	if (rc < 0)
+		return dev_err_probe(chip->dev, rc, "Couldn't request irq %s\n",
+				     name);
+
+	if (irq)
+		*irq = irqnum;
+
+	return 0;
+}
+
+static int smb5_probe(struct platform_device *pdev)
+{
+	struct power_supply_config supply_config = {};
+	struct power_supply_desc *desc;
+	struct smb5_chip *chip;
+	int rc, irq;
+
+	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->dev = &pdev->dev;
+	chip->name = pdev->name;
+
+	chip->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!chip->regmap)
+		return dev_err_probe(chip->dev, -ENODEV,
+				     "failed to locate the regmap\n");
+
+	rc = device_property_read_u32(chip->dev, "reg", &chip->base);
+	if (rc < 0)
+		return dev_err_probe(chip->dev, rc,
+				     "Couldn't read base address\n");
+
+	chip->usb_in_v_chan = devm_iio_channel_get(chip->dev, "usb_in_v_div_16");
+	if (IS_ERR(chip->usb_in_v_chan))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->usb_in_v_chan),
+				     "Couldn't get usb_in_v_div_16 IIO channel\n");
+
+	chip->usb_in_i_chan = devm_iio_channel_get(chip->dev, "usb_in_i_uv");
+	if (IS_ERR(chip->usb_in_i_chan)) {
+		return dev_err_probe(chip->dev, PTR_ERR(chip->usb_in_i_chan),
+				     "Couldn't get usb_in_i_uv IIO channel\n");
+	}
+
+	rc = smb5_init_hw(chip);
+	if (rc < 0)
+		return rc;
+
+	supply_config.drv_data = chip;
+	supply_config.of_node = pdev->dev.of_node;
+
+	desc = devm_kzalloc(chip->dev, sizeof(smb5_psy_desc), GFP_KERNEL);
+	if (!desc)
+		return -ENOMEM;
+	memcpy(desc, &smb5_psy_desc, sizeof(smb5_psy_desc));
+	desc->name =
+		devm_kasprintf(chip->dev, GFP_KERNEL, "%s-charger",
+			       (const char *)device_get_match_data(chip->dev));
+	if (!desc->name)
+		return -ENOMEM;
+
+	chip->chg_psy =
+		devm_power_supply_register(chip->dev, desc, &supply_config);
+	if (IS_ERR(chip->chg_psy))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->chg_psy),
+				     "failed to register power supply\n");
+
+	rc = power_supply_get_battery_info(chip->chg_psy, &chip->batt_info);
+	if (rc)
+		return dev_err_probe(chip->dev, rc,
+				     "Failed to get battery info\n");
+
+	rc = devm_delayed_work_autocancel(chip->dev, &chip->status_change_work,
+					  smb5_status_change_work);
+	if (rc)
+		return dev_err_probe(chip->dev, rc,
+				     "Failed to init status change work\n");
+
+	rc = (chip->batt_info->voltage_max_design_uv - 3487500) / 7500 + 1;
+	rc = regmap_update_bits(chip->regmap, chip->base + FLOAT_VOLTAGE_CFG,
+				FLOAT_VOLTAGE_SETTING_MASK, rc);
+	if (rc < 0)
+		return dev_err_probe(chip->dev, rc, "Couldn't set vbat max\n");
+
+	rc = smb5_init_irq(chip, &irq, "bat-ov", smb5_handle_batt_overvoltage);
+	if (rc < 0)
+		return rc;
+
+	rc = smb5_init_irq(chip, &chip->cable_irq, "usbin-plugin",
+			   smb5_handle_usb_plugin);
+	if (rc < 0)
+		return rc;
+
+	rc = smb5_init_irq(chip, &irq, "usbin-icl-change",
+			   smb5_handle_usb_icl_change);
+	if (rc < 0)
+		return rc;
+	rc = smb5_init_irq(chip, &irq, "wdog-bark", smb5_handle_wdog_bark);
+	if (rc < 0)
+		return rc;
+
+	rc = dev_pm_set_wake_irq(chip->dev, chip->cable_irq);
+	if (rc < 0)
+		return dev_err_probe(chip->dev, rc, "Couldn't set wake irq\n");
+
+	platform_set_drvdata(pdev, chip);
+
+	/* Initialise charger state */
+	schedule_delayed_work(&chip->status_change_work, 0);
+
+	return 0;
+}
+
+static const struct of_device_id smb5_match_id_table[] = {
+	{ .compatible = "qcom,pm8150b-charger", .data = "pm8150b" },
+	{ /* sentinal */ }
+};
+MODULE_DEVICE_TABLE(of, smb5_match_id_table);
+
+static struct platform_driver qcom_spmi_smb5 = {
+	.probe = smb5_probe,
+	.driver = {
+		.name = "qcom-pm8150b-charger",
+		.of_match_table = smb5_match_id_table,
+		},
+};
+
+module_platform_driver(qcom_spmi_smb5);
+
+MODULE_AUTHOR("Caleb Connolly <caleb.connolly@linaro.org>");
+MODULE_DESCRIPTION("Qualcomm SMB5 Charger Driver");
+MODULE_LICENSE("GPL");

From 55ef000dd83caada1adcee8c8c87715bcce786b1 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:23:32 +0800
Subject: [PATCH 08/11] power: supply: Driver for Qualcomm FG

support for pm8150 taken from:
https://github.com/map220v/sm8150-mainline
---
 drivers/power/supply/Kconfig   |    8 +
 drivers/power/supply/Makefile  |    1 +
 drivers/power/supply/qcom_fg.c | 1364 ++++++++++++++++++++++++++++++++
 3 files changed, 1373 insertions(+)
 create mode 100644 drivers/power/supply/qcom_fg.c

diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index ec3f3d5b20c8f2..b1e56c53f62485 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -1017,6 +1017,14 @@ config CHARGER_QCOM_SMB5
 	  adds support for the SMB5 switch mode battery charger found
 	  in PM8150B and related PMICs.
 
+config BATTERY_QCOM_FG
+	tristate "Qualcomm PMIC fuel gauge driver"
+	depends on MFD_SPMI_PMIC
+	help
+	  Say Y here to enable the Qualcomm PMIC Fuel Gauge driver. This
+	  adds support for battery fuel gauging and state of charge of
+	  battery connected to the fuel gauge.
+
 config FUEL_GAUGE_MM8013
 	tristate "Mitsumi MM8013 fuel gauge driver"
 	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 9237f62701582d..52a75dae57816e 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -117,4 +117,5 @@ obj-$(CONFIG_CHARGER_SURFACE)	+= surface_charger.o
 obj-$(CONFIG_BATTERY_UG3105)	+= ug3105_battery.o
 obj-$(CONFIG_CHARGER_QCOM_SMB2)	+= qcom_pmi8998_charger.o
 obj-$(CONFIG_CHARGER_QCOM_SMB5)	+= qcom_pm8150b_charger.o
+obj-$(CONFIG_BATTERY_QCOM_FG)	+= qcom_fg.o
 obj-$(CONFIG_FUEL_GAUGE_MM8013)	+= mm8013.o
diff --git a/drivers/power/supply/qcom_fg.c b/drivers/power/supply/qcom_fg.c
new file mode 100644
index 00000000000000..a3b164994fe4e1
--- /dev/null
+++ b/drivers/power/supply/qcom_fg.c
@@ -0,0 +1,1364 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Copyright (c) 2020, The Linux Foundation. All rights reserved. */
+
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/regmap.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
+/* SOC */
+#define BATT_MONOTONIC_SOC		0x009
+
+/* BATT */
+#define PARAM_ADDR_BATT_TEMP		0x150
+#define BATT_INFO_JEITA_COLD		0x162
+#define BATT_INFO_JEITA_COOL		0x163
+#define BATT_INFO_JEITA_WARM		0x164
+#define BATT_INFO_JEITA_HOT		0x165
+#define PARAM_ADDR_BATT_VOLTAGE		0x1a0
+#define PARAM_ADDR_BATT_CURRENT		0x1a2
+
+/* RRADC */
+#define ADC_RR_BATT_TEMP_LSB		0x288
+
+/* MEMIF */
+#define MEM_INTF_STS(chip)			(chip->ops->memif_base + 0x10)
+#define MEM_INTF_CFG(chip)			(chip->ops->memif_base + 0x50)
+#define MEM_INTF_CTL(chip)			(chip->ops->memif_base + 0x51)
+#define MEM_INTF_IMA_CFG(chip)			(chip->ops->memif_base + 0x52)
+#define MEM_INTF_IMA_EXP_STS(chip)		(chip->ops->memif_base + 0x55)
+#define MEM_INTF_IMA_HW_STS(chip)		(chip->ops->memif_base + 0x56)
+#define MEM_INTF_IMA_ERR_STS(chip)		(chip->ops->memif_base + 0x5f)
+#define MEM_INTF_IMA_BYTE_EN(chip)		(chip->ops->memif_base + 0x60)
+#define MEM_INTF_ADDR_LSB(chip)			(chip->ops->memif_base + 0x61)
+#define MEM_INTF_RD_DATA0(chip)			(chip->ops->memif_base + 0x67)
+#define MEM_INTF_WR_DATA0(chip)			(chip->ops->memif_base + 0x63)
+#define MEM_IF_DMA_STS(chip)			(chip->ops->memif_base + 0x70)
+#define MEM_IF_DMA_CTL(chip)			(chip->ops->memif_base + 0x71)
+
+/* SRAM addresses */
+#define TEMP_THRESHOLD			0x454
+#define BATT_TEMP			0x550
+#define BATT_VOLTAGE_CURRENT		0x5cc
+
+#define BATT_TEMP_LSB_MASK		GENMASK(7, 0)
+#define BATT_TEMP_MSB_MASK		GENMASK(2, 0)
+
+#define BATT_TEMP_JEITA_COLD		100
+#define BATT_TEMP_JEITA_COOL		50
+#define BATT_TEMP_JEITA_WARM		400
+#define BATT_TEMP_JEITA_HOT		450
+
+#define MEM_INTF_AVAIL			BIT(0)
+#define MEM_INTF_CTL_BURST		BIT(7)
+#define MEM_INTF_CTL_WR_EN		BIT(6)
+#define RIF_MEM_ACCESS_REQ		BIT(7)
+
+#define MEM_IF_TIMEOUT_MS		5000
+#define SRAM_ACCESS_RELEASE_DELAY_MS	500
+
+struct qcom_fg_chip;
+
+struct qcom_fg_ops {
+	int (*get_capacity)(struct qcom_fg_chip *chip, int *);
+	int (*get_temperature)(struct qcom_fg_chip *chip, int *);
+	int (*get_current)(struct qcom_fg_chip *chip, int *);
+	int (*get_voltage)(struct qcom_fg_chip *chip, int *);
+	int (*get_temp_threshold)(struct qcom_fg_chip *chip,
+			enum power_supply_property psp, int *);
+	int (*set_temp_threshold)(struct qcom_fg_chip *chip,
+			enum power_supply_property psp, int);
+
+	short memif_base;
+};
+
+struct qcom_fg_chip {
+	struct device *dev;
+	unsigned int base;
+	struct regmap *regmap;
+	const struct qcom_fg_ops *ops;
+	struct notifier_block nb;
+
+	struct power_supply *batt_psy;
+	struct power_supply_battery_info *batt_info;
+	struct power_supply *chg_psy;
+	int status;
+	struct delayed_work status_changed_work;
+
+	struct completion sram_access_granted;
+	struct completion sram_access_revoked;
+	struct workqueue_struct *sram_wq;
+	struct delayed_work sram_release_access_work;
+	spinlock_t sram_request_lock;
+	spinlock_t sram_rw_lock;
+	int sram_requests;
+};
+
+/************************
+ * IO FUNCTIONS
+ * **********************/
+
+/**
+ * @brief qcom_fg_read() - Read multiple registers with regmap_bulk_read
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to read values into
+ * @param addr Address to read from
+ * @param len Number of registers (bytes) to read
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_read(struct qcom_fg_chip *chip, u8 *val, u16 addr, int len)
+{
+	if (((chip->base + addr) & 0xff00) == 0)
+		return -EINVAL;
+
+	dev_vdbg(chip->dev, "%s: Reading 0x%x bytes from 0x%x", __func__, len, addr);
+
+	return regmap_bulk_read(chip->regmap, chip->base + addr, val, len);
+}
+
+/**
+ * @brief qcom_fg_write() - Write multiple registers with regmap_bulk_write
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to write values from
+ * @param addr Address to write to
+ * @param len Number of registers (bytes) to write
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_write(struct qcom_fg_chip *chip, u8 *val, u16 addr, int len)
+{
+	bool sec_access = (addr & 0xff) > 0xd0;
+	u8 sec_addr_val = 0xa5;
+	int ret;
+
+	if (((chip->base + addr) & 0xff00) == 0)
+			return -EINVAL;
+
+	dev_vdbg(chip->dev, "%s: Writing 0x%x to 0x%x", __func__, *val, addr);
+
+	if (sec_access) {
+		ret = regmap_bulk_write(chip->regmap,
+				((chip->base + addr) & 0xff00) | 0xd0,
+				&sec_addr_val, 1);
+		if (ret)
+			return ret;
+	}
+
+	return regmap_bulk_write(chip->regmap, chip->base + addr, val, len);
+}
+
+/**
+ * @brief qcom_fg_masked_write() - like qcom_fg_write but applies
+ * a mask first.
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to write values from
+ * @param addr Address to write to
+ * @param len Number of registers (bytes) to write
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_masked_write(struct qcom_fg_chip *chip, u16 addr, u8 mask, u8 val)
+{
+	u8 reg;
+	int ret;
+
+	ret = qcom_fg_read(chip, &reg, addr, 1);
+	if (ret)
+		return ret;
+
+	reg &= ~mask;
+	reg |= val & mask;
+
+	return qcom_fg_write(chip, &reg, addr, 1);
+}
+
+/************************
+ * SRAM FUNCTIONS
+ * **********************/
+
+/**
+ * @brief qcom_fg_sram_check_access() - Check if SRAM is accessible
+ *
+ * @param chip Pointer to chip
+ * @return bool true if accessible, false otherwise
+ */
+static bool qcom_fg_sram_check_access(struct qcom_fg_chip *chip)
+{
+	u8 mem_if_status;
+	int ret;
+
+	ret = qcom_fg_read(chip, &mem_if_status,
+		MEM_INTF_STS(chip), 1);
+
+	if (ret || !(mem_if_status & MEM_INTF_AVAIL))
+		return false;
+
+	ret = qcom_fg_read(chip, &mem_if_status,
+		MEM_INTF_CFG(chip), 1);
+
+	if (ret)
+		return false;
+
+	return !!(mem_if_status & RIF_MEM_ACCESS_REQ);
+}
+
+/**
+ * @brief qcom_fg_sram_request_access() - Request access to SRAM and wait for it
+ * 
+ * @param chip Pointer to chip
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_sram_request_access(struct qcom_fg_chip *chip)
+{
+	bool sram_accessible;
+	int ret;
+
+	spin_lock(&chip->sram_request_lock);
+
+	sram_accessible = qcom_fg_sram_check_access(chip);
+
+	dev_vdbg(chip->dev, "Requesting SRAM access, current state: %d, requests: %d\n",
+		sram_accessible, chip->sram_requests);
+
+	if (!sram_accessible && chip->sram_requests == 0) {
+		ret = qcom_fg_masked_write(chip, MEM_INTF_CFG(chip),
+				RIF_MEM_ACCESS_REQ, RIF_MEM_ACCESS_REQ);
+		if (ret) {
+			dev_err(chip->dev,
+				"Failed to set SRAM access request bit: %d\n", ret);
+
+			spin_unlock(&chip->sram_request_lock);
+			return ret;
+		}
+	}
+
+	chip->sram_requests++;
+
+	spin_unlock(&chip->sram_request_lock);
+
+	/* Wait to get access to SRAM, and try again if interrupted */
+	do {
+		ret = wait_for_completion_interruptible_timeout(
+			&chip->sram_access_granted,
+			msecs_to_jiffies(MEM_IF_TIMEOUT_MS));
+	} while(ret == -ERESTARTSYS);
+
+	if (ret <= 0) {
+		ret = -ETIMEDOUT;
+
+		spin_lock(&chip->sram_request_lock);
+		chip->sram_requests--;
+		spin_unlock(&chip->sram_request_lock);
+	} else {
+		ret = 0;
+
+		reinit_completion(&chip->sram_access_revoked);
+	}
+
+	return ret;
+}
+
+/**
+ * @brief qcom_fg_sram_release_access() - Release access to SRAM
+ *
+ * @param chip Pointer to chip
+ * @return int 0 on success, negative errno on error
+ */
+static void qcom_fg_sram_release_access(struct qcom_fg_chip *chip)
+{
+	spin_lock(&chip->sram_request_lock);
+
+	chip->sram_requests--;
+
+	if(WARN(chip->sram_requests < 0,
+			"sram_requests=%d, cannot be negative! resetting to 0.\n",
+			chip->sram_requests))
+		chip->sram_requests = 0;
+
+	if(chip->sram_requests == 0)
+		/* Schedule access release */
+		queue_delayed_work(chip->sram_wq, &chip->sram_release_access_work,
+			msecs_to_jiffies(SRAM_ACCESS_RELEASE_DELAY_MS));
+
+	spin_unlock(&chip->sram_request_lock);
+}
+
+static void qcom_fg_sram_release_access_worker(struct work_struct *work)
+{
+	struct qcom_fg_chip *chip;
+	bool wait = false;
+	int ret;
+
+	chip = container_of(work, struct qcom_fg_chip, sram_release_access_work.work);
+
+	spin_lock(&chip->sram_request_lock);
+
+	/* Request access release if there are still no access requests */
+	if(chip->sram_requests == 0) {
+		qcom_fg_masked_write(chip, MEM_INTF_CFG(chip), RIF_MEM_ACCESS_REQ, 0);
+		wait = true;
+	}
+
+	spin_unlock(&chip->sram_request_lock);
+
+	if(!wait)
+		return;
+
+	/* Wait for SRAM access to be released, and try again if interrupted */
+	do {
+		ret = wait_for_completion_interruptible_timeout(
+			&chip->sram_access_revoked,
+			msecs_to_jiffies(MEM_IF_TIMEOUT_MS));
+	} while(ret == -ERESTARTSYS);
+
+	reinit_completion(&chip->sram_access_granted);
+}
+
+/**
+ * @brief qcom_fg_sram_config_access() - Configure access to SRAM
+ *
+ * @param chip Pointer to chip
+ * @param write 0 for read access, 1 for write access
+ * @param burst 1 to access mutliple addresses successively
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_sram_config_access(struct qcom_fg_chip *chip,
+		bool write, bool burst)
+{
+	u8 intf_ctl;
+	int ret;
+
+	intf_ctl = (write ? MEM_INTF_CTL_WR_EN : 0)
+			| (burst ? MEM_INTF_CTL_BURST : 0);
+
+	ret = qcom_fg_write(chip, &intf_ctl,
+			MEM_INTF_CTL(chip), 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to configure SRAM access: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_sram_read() - Read data from SRAM
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to read values into
+ * @param addr Address to read from
+ * @param len Number of bytes to read
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_sram_read(struct qcom_fg_chip *chip,
+		u8 *val, u16 addr, int len, int offset)
+{
+	u8 *rd_data = val;
+	int ret = 0;
+
+	ret = qcom_fg_sram_request_access(chip);
+	if (ret) {
+		dev_err(chip->dev, "Failed to request SRAM access: %d", ret);
+		return ret;
+	}
+
+	spin_lock(&chip->sram_rw_lock);
+
+	dev_vdbg(chip->dev,
+		"Reading address 0x%x with offset %d of length %d from SRAM",
+		addr, len, offset);
+
+	ret = qcom_fg_sram_config_access(chip, 0, (len > 4));
+	if (ret) {
+		dev_err(chip->dev, "Failed to configure SRAM access: %d", ret);
+		goto out;
+	}
+
+	while(len > 0) {
+		/* Set SRAM address register */
+		ret = qcom_fg_write(chip, (u8 *) &addr,
+				MEM_INTF_ADDR_LSB(chip), 2);
+		if (ret) {
+			dev_err(chip->dev, "Failed to set SRAM address: %d", ret);
+			goto out;
+		}
+
+		ret = qcom_fg_read(chip, rd_data,
+				MEM_INTF_RD_DATA0(chip) + offset, len);
+
+		addr += 4;
+
+		if (ret)
+			goto out;
+
+		rd_data += 4 - offset;
+		len -= 4 - offset;
+		offset = 0;
+	}
+out:
+	spin_unlock(&chip->sram_rw_lock);
+	qcom_fg_sram_release_access(chip);
+
+	return ret;
+}
+
+/**
+ * @brief qcom_fg_sram_write() - Write data to SRAM
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to write values from
+ * @param addr Address to write to
+ * @param len Number of bytes to write
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_sram_write(struct qcom_fg_chip *chip,
+		u8 *val, u16 addr, int len, int offset)
+{
+	u8 *wr_data = val;
+	int ret;
+
+	ret = qcom_fg_sram_request_access(chip);
+	if (ret) {
+		dev_err(chip->dev, "Failed to request SRAM access: %d", ret);
+		return ret;
+	}
+
+	spin_lock(&chip->sram_rw_lock);
+
+	dev_vdbg(chip->dev,
+		"Wrtiting address 0x%x with offset %d of length %d to SRAM",
+		addr, len, offset);
+
+	ret = qcom_fg_sram_config_access(chip, 1, (len > 4));
+	if (ret) {
+		dev_err(chip->dev, "Failed to configure SRAM access: %d", ret);
+		goto out;
+	}
+
+	while(len > 0) {
+		/* Set SRAM address register */
+		ret = qcom_fg_write(chip, (u8 *) &addr,
+				MEM_INTF_ADDR_LSB(chip), 2);
+		if (ret) {
+			dev_err(chip->dev, "Failed to set SRAM address: %d", ret);
+			goto out;
+		}
+
+		ret = qcom_fg_write(chip, wr_data,
+				MEM_INTF_WR_DATA0(chip) + offset, len);
+
+		addr += 4;
+
+		if (ret)
+			goto out;
+
+		wr_data += 4 - offset;
+		len -= 4 - offset;
+		offset = 0;
+	}
+out:
+	spin_unlock(&chip->sram_rw_lock);
+	qcom_fg_sram_release_access(chip);
+
+	return ret;
+}
+
+/*************************
+ * BATTERY STATUS
+ * ***********************/
+
+/**
+ * @brief qcom_fg_get_capacity() - Get remaining capacity of battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_get_capacity(struct qcom_fg_chip *chip, int *val)
+{
+	u8 cap[2];
+	int ret;
+
+	ret = qcom_fg_read(chip, cap, BATT_MONOTONIC_SOC, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read capacity: %d", ret);
+		return ret;
+	}
+
+	if (cap[0] != cap[1]) {
+		cap[0] = cap[0] < cap[1] ? cap[0] : cap[1];
+	}
+
+	*val = DIV_ROUND_CLOSEST((cap[0] - 1) * 98, 0xff - 2) + 1;
+
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_get_temperature() - Get temperature of battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_get_temperature(struct qcom_fg_chip *chip, int *val)
+{
+	int temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_sram_read(chip, readval, BATT_TEMP, 2, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read temperature: %d", ret);
+		return ret;
+	}
+
+	temp = readval[1] << 8 | readval[0];
+	*val = temp * 625 / 1000 - 2730;
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_get_current() - Get current being drawn from battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_get_current(struct qcom_fg_chip *chip, int *val)
+{
+	s16 temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_sram_read(chip, readval, BATT_VOLTAGE_CURRENT, 2, 3);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read current: %d", ret);
+		return ret;
+	}
+
+	temp = (s16)(readval[1] << 8 | readval[0]);
+	*val = div_s64((s64)temp * 152587, 1000);
+
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_get_voltage() - Get voltage of battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_get_voltage(struct qcom_fg_chip *chip, int *val)
+{
+	int temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_sram_read(chip, readval, BATT_VOLTAGE_CURRENT, 2, 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read voltage: %d", ret);
+		return ret;
+	}
+
+	temp = readval[1] << 8 | readval[0];
+	*val = div_u64((u64)temp * 152587, 1000);
+
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_get_temp_threshold() - Get configured temperature thresholds
+ *
+ * @param chip Pointer to chip
+ * @param psp Power supply property of temperature limit
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_get_temp_threshold(struct qcom_fg_chip *chip,
+				enum power_supply_property psp, int *val)
+{
+	u8 temp;
+	int offset;
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP_MIN:
+		offset = 0;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_MAX:
+		offset = 1;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MIN:
+		offset = 2;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		offset = 3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = qcom_fg_sram_read(chip, &temp, TEMP_THRESHOLD, 1, offset);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to read JEITA property %d level: %d\n", psp, ret);
+		return ret;
+	}
+
+	*val = (temp - 30) * 10;
+
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_set_temp_threshold() - Configure temperature thresholds
+ *
+ * @param chip Pointer to chip
+ * @param psp Power supply property of temperature limit
+ * @param val Pointer to get value from
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_set_temp_threshold(struct qcom_fg_chip *chip,
+				enum power_supply_property psp, int val)
+{
+	u8 temp;
+	int offset;
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP_MIN:
+		offset = 0;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_MAX:
+		offset = 1;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MIN:
+		offset = 2;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		offset = 3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	temp = val / 10 + 30;
+
+	ret = qcom_fg_sram_write(chip, &temp, TEMP_THRESHOLD, 1, offset);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to write JEITA property %d level: %d\n", psp, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*************************
+ * BATTERY STATUS, GEN3
+ * ***********************/
+
+/**
+ * @brief qcom_fg_gen3_get_temperature() - Get temperature of battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_gen3_get_temperature(struct qcom_fg_chip *chip, int *val)
+{
+	int temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_read(chip, readval, PARAM_ADDR_BATT_TEMP, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read temperature: %d\n", ret);
+		return ret;
+	}
+
+	temp = ((readval[1] & BATT_TEMP_MSB_MASK) << 8) |
+		(readval[0] & BATT_TEMP_LSB_MASK);
+	temp = DIV_ROUND_CLOSEST(temp * 10, 4);
+
+	*val = temp -2730;
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_gen3_get_current() - Get current being drawn from battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_gen3_get_current(struct qcom_fg_chip *chip, int *val)
+{
+	s16 temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_read(chip, readval, PARAM_ADDR_BATT_CURRENT, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read current: %d\n", ret);
+		return ret;
+	}
+
+	//handle rev 1 too
+	temp = (s16)(readval[1] << 8 | readval[0]);
+	*val = div_s64((s64)temp * 488281, 1000);
+
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_gen3_get_voltage() - Get voltage of battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_gen3_get_voltage(struct qcom_fg_chip *chip, int *val)
+{
+	int temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_read(chip, readval, PARAM_ADDR_BATT_VOLTAGE, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read voltage: %d\n", ret);
+		return ret;
+	}
+
+	//handle rev 1 too
+	temp = readval[1] << 8 | readval[0];
+	*val = div_u64((u64)temp * 122070, 1000);
+	return 0;
+}
+
+/**
+ * @brief qcom_fg_gen3_get_temp_threshold() - Get configured temperature thresholds
+ *
+ * @param chip Pointer to chip
+ * @param psp Power supply property of temperature limit
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_gen3_get_temp_threshold(struct qcom_fg_chip *chip,
+				enum power_supply_property psp, int *val)
+{
+	u8 temp;
+	u16 reg;
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP_MIN:
+		reg = BATT_INFO_JEITA_COLD;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_MAX:
+		reg = BATT_INFO_JEITA_HOT;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MIN:
+		reg = BATT_INFO_JEITA_COOL;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		reg = BATT_INFO_JEITA_WARM;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = qcom_fg_read(chip, &temp, reg, 1);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to read JEITA property %d level: %d\n", psp, ret);
+		return ret;
+	}
+
+	/* Resolution is 0.5C. Base is -30C. */
+	*val = (((5 * temp) / 10) - 30) * 10;
+	return 0;
+}
+
+/*************************
+ * BATTERY STATUS, GEN4
+ * ***********************/
+
+/**
+ * @brief qcom_fg_gen4_get_temperature() - Get temperature of battery
+ *
+ * @param chip Pointer to chip
+ * @param val Pointer to store value at
+ * @return int 0 on success, negative errno on error
+ */
+static int qcom_fg_gen4_get_temperature(struct qcom_fg_chip *chip, int *val)
+{
+	int temp;
+	u8 readval[2];
+	int ret;
+
+	ret = qcom_fg_read(chip, readval, ADC_RR_BATT_TEMP_LSB, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read temperature: %d", ret);
+		return ret;
+	}
+
+	temp = readval[1] << 8 | readval[0];
+	*val = temp * 10;
+	return 0;
+}
+
+/************************
+ * BATTERY POWER SUPPLY
+ * **********************/
+
+/* Pre-Gen3 fuel gauge. PMI8996 and older */
+static const struct qcom_fg_ops ops_fg = {
+	.get_capacity = qcom_fg_get_capacity,
+	.get_temperature = qcom_fg_get_temperature,
+	.get_current = qcom_fg_get_current,
+	.get_voltage = qcom_fg_get_voltage,
+	.get_temp_threshold = qcom_fg_get_temp_threshold,
+	.set_temp_threshold = qcom_fg_set_temp_threshold,
+	.memif_base = 0x400,
+};
+
+/* Gen3 fuel gauge. PMI8998 and newer */
+static const struct qcom_fg_ops ops_fg_gen3 = {
+	.get_capacity = qcom_fg_get_capacity,
+	.get_temperature = qcom_fg_gen3_get_temperature,
+	.get_current = qcom_fg_gen3_get_current,
+	.get_voltage = qcom_fg_gen3_get_voltage,
+	.get_temp_threshold = qcom_fg_gen3_get_temp_threshold,
+	.memif_base = 0x400,
+};
+
+/* Gen4 fuel gauge. PM8150B and newer */
+static const struct qcom_fg_ops ops_fg_gen4 = {
+	.get_capacity = qcom_fg_get_capacity,
+	.get_temperature = qcom_fg_gen4_get_temperature,
+	.get_current = qcom_fg_gen3_get_current,
+	.get_voltage = qcom_fg_gen3_get_voltage,
+	.get_temp_threshold = qcom_fg_gen3_get_temp_threshold,
+	.memif_base = 0x300,
+};
+
+static enum power_supply_property qcom_fg_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_MIN,
+	POWER_SUPPLY_PROP_TEMP_MAX,
+	POWER_SUPPLY_PROP_TEMP_ALERT_MIN,
+	POWER_SUPPLY_PROP_TEMP_ALERT_MAX,
+};
+
+static int qcom_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct qcom_fg_chip *chip = power_supply_get_drvdata(psy);
+	int temp, ret = 0;
+
+	dev_dbg(chip->dev, "Getting property: %d", psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		/* Get status from charger if available */
+		if (chip->chg_psy &&
+			chip->status != POWER_SUPPLY_STATUS_UNKNOWN) {
+			val->intval = chip->status;
+			break;
+		} else {
+			/*
+			 * Fall back to capacity and current-based
+			 * status checking
+			 */
+			ret = chip->ops->get_capacity(chip, &temp);
+			if (ret) {
+				val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+				break;
+			}
+			if (temp == 100) {
+				val->intval = POWER_SUPPLY_STATUS_FULL;
+				break;
+			}
+
+			ret = chip->ops->get_current(chip, &temp);
+			if (ret) {
+				val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+				break;
+			}
+			if (temp < 0)
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			else if (temp > 0)
+				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+			else
+				val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		}
+
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		ret = chip->ops->get_capacity(chip, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		ret = chip->ops->get_current(chip, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		ret = chip->ops->get_voltage(chip, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = chip->batt_info->voltage_min_design_uv;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = chip->batt_info->voltage_max_design_uv;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = chip->batt_info->charge_full_design_uah;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		ret = chip->ops->get_temperature(chip, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_TEMP_MIN:
+	case POWER_SUPPLY_PROP_TEMP_MAX:
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MIN:
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		ret = chip->ops->get_temp_threshold(chip, psp, &val->intval);
+		break;
+	default:
+		dev_err(chip->dev, "invalid property: %d\n", psp);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct power_supply_desc batt_psy_desc = {
+	.name = "qcom-battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = qcom_fg_props,
+	.num_properties = ARRAY_SIZE(qcom_fg_props),
+	.get_property = qcom_fg_get_property,
+};
+
+/********************
+ * INIT FUNCTIONS
+ * ******************/
+
+static int qcom_fg_iacs_clear_sequence(struct qcom_fg_chip *chip)
+{
+	u8 temp;
+	int ret;
+
+	/* clear the error */
+	ret = qcom_fg_masked_write(chip, MEM_INTF_IMA_CFG(chip), BIT(2), BIT(2));
+	if (ret) {
+		dev_err(chip->dev, "Failed to write IMA_CFG: %d\n", ret);
+		return ret;
+	}
+
+	temp = 0x4;
+	ret = qcom_fg_write(chip, &temp, MEM_INTF_ADDR_LSB(chip) + 1, 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to write MEM_INTF_ADDR_MSB: %d\n", ret);
+		return ret;
+	}
+
+	temp = 0x0;
+	ret = qcom_fg_write(chip, &temp, MEM_INTF_WR_DATA0(chip) + 3, 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to write WR_DATA3: %d\n", ret);
+		return ret;
+	}
+
+	ret = qcom_fg_read(chip, &temp, MEM_INTF_RD_DATA0(chip) + 3, 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to write RD_DATA3: %d\n", ret);
+		return ret;
+	}
+
+	ret = qcom_fg_masked_write(chip, MEM_INTF_IMA_CFG(chip), BIT(2), 0);
+	if (ret) {
+		dev_err(chip->dev, "Failed to write IMA_CFG: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int qcom_fg_clear_ima(struct qcom_fg_chip *chip,
+		bool check_hw_sts)
+{
+	u8 err_sts, exp_sts, hw_sts;
+	bool run_err_clr_seq = false;
+	int ret;
+
+	ret = qcom_fg_read(chip, &err_sts,
+			MEM_INTF_IMA_ERR_STS(chip), 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read IMA_ERR_STS: %d\n", ret);
+		return ret;
+	}
+
+	ret = qcom_fg_read(chip, &exp_sts,
+			MEM_INTF_IMA_EXP_STS(chip), 1);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read IMA_EXP_STS: %d\n", ret);
+		return ret;
+	}
+
+	if (check_hw_sts) {
+		ret = qcom_fg_read(chip, &hw_sts,
+				MEM_INTF_IMA_HW_STS(chip), 1);
+		if (ret) {
+			dev_err(chip->dev, "Failed to read IMA_HW_STS: %d\n", ret);
+			return ret;
+		}
+		/*
+		 * Lower nibble should be equal to upper nibble before SRAM
+		 * transactions begins from SW side.
+		 */
+		if ((hw_sts & 0x0f) != hw_sts >> 4) {
+			dev_dbg(chip->dev, "IMA HW not in correct state, hw_sts=%x\n",
+					hw_sts);
+			run_err_clr_seq = true;
+		}
+	}
+
+	if (exp_sts & (BIT(0) | BIT(1) | BIT(3) |
+		BIT(4) | BIT(5) | BIT(6) |
+		BIT(7))) {
+		dev_dbg(chip->dev, "IMA exception bit set, exp_sts=%x\n", exp_sts);
+		run_err_clr_seq = true;
+	}
+
+	if (run_err_clr_seq) {
+		ret = qcom_fg_iacs_clear_sequence(chip);
+		if (!ret)
+			return -EAGAIN;
+	}
+
+	return 0;
+}
+
+static irqreturn_t qcom_fg_handle_soc_delta(int irq, void *data)
+{
+	struct qcom_fg_chip *chip = data;
+
+	/* Signal change in state of charge */
+	power_supply_changed(chip->batt_psy);
+	dev_dbg(chip->dev, "SOC changed");
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t qcom_fg_handle_mem_avail(int irq, void *data)
+{
+	struct qcom_fg_chip *chip = data;
+
+	if (qcom_fg_sram_check_access(chip)) {
+		complete_all(&chip->sram_access_granted);
+		dev_dbg(chip->dev, "SRAM access granted");
+	} else {
+		complete_all(&chip->sram_access_revoked);
+		dev_dbg(chip->dev, "SRAM access revoked");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void qcom_fg_status_changed_worker(struct work_struct *work)
+{
+	struct qcom_fg_chip *chip = container_of(work, struct qcom_fg_chip,
+						status_changed_work.work);
+
+	power_supply_changed(chip->batt_psy);
+}
+
+static int qcom_fg_notifier_call(struct notifier_block *nb,
+		unsigned long val, void *v)
+{
+	struct qcom_fg_chip *chip = container_of(nb, struct qcom_fg_chip, nb);
+	struct power_supply *psy = v;
+	union power_supply_propval propval;
+	int ret;
+
+	if (psy == chip->chg_psy) {
+		ret = power_supply_get_property(psy,
+				POWER_SUPPLY_PROP_STATUS, &propval);
+		if (ret)
+			chip->status = POWER_SUPPLY_STATUS_UNKNOWN;
+
+		chip->status = propval.intval;
+
+		power_supply_changed(chip->batt_psy);
+
+		if (chip->status == POWER_SUPPLY_STATUS_UNKNOWN) {
+			/*
+			 * REVISIT: Find better solution or remove current-based
+			 * status checking once checking is properly implemented
+			 * in charger drivers
+
+			 * Sometimes it take a while for current to stabilize,
+			 * so signal property change again later to make sure
+			 * current-based status is properly detected.
+			 */
+			cancel_delayed_work_sync(&chip->status_changed_work);
+			schedule_delayed_work(&chip->status_changed_work,
+						msecs_to_jiffies(1000));
+		}
+	}
+
+	return NOTIFY_OK;
+}
+
+static int qcom_fg_probe(struct platform_device *pdev)
+{
+	struct power_supply_config supply_config = {};
+	struct qcom_fg_chip *chip;
+	const __be32 *prop_addr;
+	int irq;
+	u8 dma_status;
+	bool error_present;
+	int ret;
+
+	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->dev = &pdev->dev;
+	chip->ops = of_device_get_match_data(&pdev->dev);
+
+	chip->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!chip->regmap) {
+		dev_err(chip->dev, "Failed to locate the regmap\n");
+		return -ENODEV;
+	}
+
+	/* Get base address */
+	prop_addr = of_get_address(pdev->dev.of_node, 0, NULL, NULL);
+	if (!prop_addr) {
+		dev_err(chip->dev, "Failed to read SOC base address from dt\n");
+		return -EINVAL;
+	}
+	chip->base = be32_to_cpu(*prop_addr);
+
+	/*
+	 * Change the FG_MEM_INT interrupt to track IACS_READY
+	 * condition instead of end-of-transaction. This makes sure
+	 * that the next transaction starts only after the hw is ready.
+	 * IACS_INTR_SRC_SLCT is BIT(3)
+	 */
+	ret = qcom_fg_masked_write(chip,
+		MEM_INTF_IMA_CFG(chip), BIT(3), BIT(3));
+	if (ret) {
+		dev_err(chip->dev,
+			"Failed to configure interrupt sourete: %d\n", ret);
+		return ret;
+	}
+
+	ret = qcom_fg_clear_ima(chip, true);
+	if (ret && ret != -EAGAIN) {
+		dev_err(chip->dev, "Failed to clear IMA exception: %d\n", ret);
+		return ret;
+	}
+
+	/* Check and clear DMA errors */
+	ret = qcom_fg_read(chip, &dma_status, MEM_IF_DMA_STS(chip), 1);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to read dma_status: %d\n", ret);
+		return ret;
+	}
+
+	error_present = dma_status & (BIT(1) | BIT(2));
+	ret = qcom_fg_masked_write(chip, MEM_IF_DMA_CTL(chip), BIT(0),
+			error_present ? BIT(0) : 0);
+	if (ret < 0) {
+		dev_err(chip->dev, "Failed to write dma_ctl: %d\n", ret);
+		return ret;
+	}
+
+	supply_config.drv_data = chip;
+	supply_config.of_node = pdev->dev.of_node;
+
+	chip->batt_psy = devm_power_supply_register(chip->dev,
+			&batt_psy_desc, &supply_config);
+	if (IS_ERR(chip->batt_psy)) {
+		if (PTR_ERR(chip->batt_psy) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Failed to register battery\n");
+		return PTR_ERR(chip->batt_psy);
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	ret = power_supply_get_battery_info(chip->batt_psy, &chip->batt_info);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to get battery info: %d\n", ret);
+		return ret;
+	}
+
+	/* Initialize SRAM */
+	if (of_device_is_compatible(pdev->dev.of_node, "qcom,pmi8994-fg")) {
+		irq = of_irq_get_byname(pdev->dev.of_node, "mem-avail");
+		if (irq < 0) {
+			dev_err(&pdev->dev, "Failed to get irq mem-avail byname: %d\n",
+				irq);
+			return irq;
+		}
+
+		init_completion(&chip->sram_access_granted);
+		init_completion(&chip->sram_access_revoked);
+
+		chip->sram_wq = create_singlethread_workqueue("qcom_fg");
+		INIT_DELAYED_WORK(&chip->sram_release_access_work,
+			qcom_fg_sram_release_access_worker);
+
+		ret = devm_request_threaded_irq(chip->dev, irq, NULL,
+						qcom_fg_handle_mem_avail,
+						IRQF_ONESHOT, "mem-avail", chip);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to request mem-avail IRQ: %d\n", ret);
+			return ret;
+		}
+
+		spin_lock_init(&chip->sram_request_lock);
+		spin_lock_init(&chip->sram_rw_lock);
+		chip->sram_requests = 0;
+	}
+
+	/* Set default temperature thresholds */
+	if (chip->ops->set_temp_threshold) {
+		ret = chip->ops->set_temp_threshold(chip,
+						POWER_SUPPLY_PROP_TEMP_MIN,
+						BATT_TEMP_JEITA_COLD);
+		if (ret) {
+			dev_err(chip->dev,
+				"Failed to set cold threshold: %d\n", ret);
+			return ret;
+		}
+
+		ret = chip->ops->set_temp_threshold(chip,
+						POWER_SUPPLY_PROP_TEMP_MAX,
+						BATT_TEMP_JEITA_WARM);
+		if (ret) {
+			dev_err(chip->dev,
+				"Failed to set warm threshold: %d\n", ret);
+			return ret;
+		}
+
+		ret = chip->ops->set_temp_threshold(chip,
+						POWER_SUPPLY_PROP_TEMP_ALERT_MIN,
+						BATT_TEMP_JEITA_COOL);
+		if (ret) {
+			dev_err(chip->dev,
+				"Failed to set cool threshold: %d\n", ret);
+			return ret;
+		}
+
+		ret = chip->ops->set_temp_threshold(chip,
+						POWER_SUPPLY_PROP_TEMP_ALERT_MAX,
+						BATT_TEMP_JEITA_HOT);
+		if (ret) {
+			dev_err(chip->dev,
+				"Failed to set hot threshold: %d\n", ret);
+			return ret;
+		}
+	}
+
+	/* Get soc-delta IRQ */
+	irq = of_irq_get_byname(pdev->dev.of_node, "soc-delta");
+	if (irq < 0) {
+		dev_err(&pdev->dev, "Failed to get irq soc-delta byname: %d\n",
+			irq);
+		return irq;
+	}
+
+	ret = devm_request_threaded_irq(chip->dev, irq, NULL,
+					qcom_fg_handle_soc_delta,
+					IRQF_ONESHOT, "soc-delta", chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to request soc-delta IRQ: %d\n", ret);
+		return ret;
+	}
+
+	/* Optional: Get charger power supply for status checking */
+	chip->chg_psy = power_supply_get_by_phandle(chip->dev->of_node,
+							"power-supplies");
+	if (IS_ERR(chip->chg_psy)) {
+		ret = PTR_ERR(chip->chg_psy);
+		dev_warn(chip->dev, "Failed to get charger supply: %d\n", ret);
+		chip->chg_psy = NULL;
+	}
+
+	if (chip->chg_psy) {
+		INIT_DELAYED_WORK(&chip->status_changed_work,
+			qcom_fg_status_changed_worker);
+
+		chip->nb.notifier_call = qcom_fg_notifier_call;
+		ret = power_supply_reg_notifier(&chip->nb);
+		if (ret) {
+			dev_err(chip->dev,
+				"Failed to register notifier: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void qcom_fg_remove(struct platform_device *pdev)
+{
+	struct qcom_fg_chip *chip = platform_get_drvdata(pdev);
+
+	power_supply_put_battery_info(chip->batt_psy, chip->batt_info);
+
+	if(chip->sram_wq)
+		destroy_workqueue(chip->sram_wq);
+}
+
+static const struct of_device_id fg_match_id_table[] = {
+	{ .compatible = "qcom,pmi8994-fg", .data = &ops_fg },
+	{ .compatible = "qcom,pmi8998-fg", .data = &ops_fg_gen3 },
+	{ .compatible = "qcom,pm8150b-fg", .data = &ops_fg_gen4 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, fg_match_id_table);
+
+static struct platform_driver qcom_fg_driver = {
+	.probe = qcom_fg_probe,
+	.remove_new = qcom_fg_remove,
+	.driver = {
+		.name = "qcom-fg",
+		.of_match_table = fg_match_id_table,
+	},
+};
+
+module_platform_driver(qcom_fg_driver);
+
+MODULE_AUTHOR("Caleb Connolly <caleb@connolly.tech>");
+MODULE_AUTHOR("Joel Selvaraj <jo@jsfamily.in>");
+MODULE_AUTHOR("Yassine Oudjana <y.oudjana@protonmail.com>");
+MODULE_DESCRIPTION("Qualcomm PMIC Fuel Gauge Driver");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file

From 1f46989b918c9d55fefcab555b101614162c0d0f Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:25:55 +0800
Subject: [PATCH 09/11] arm64: dts: qcom: pm8150b: Add a charger

---
 arch/arm64/boot/dts/qcom/pm8150b.dtsi | 32 +++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/pm8150b.dtsi b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
index 3f7b0b6a1d109b..d0cfe63619547f 100644
--- a/arch/arm64/boot/dts/qcom/pm8150b.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
@@ -107,6 +107,26 @@
 			#thermal-sensor-cells = <0>;
 		};
 
+		pm8150b_charger: charger@1000 {
+			compatible = "qcom,pm8150b-charger";
+			reg = <0x1000>;
+
+			interrupts = <0x2 0x13 0x4 IRQ_TYPE_EDGE_BOTH>,
+				     <0x2 0x12 0x2 IRQ_TYPE_EDGE_BOTH>,
+				     <0x2 0x16 0x1 IRQ_TYPE_EDGE_RISING>,
+				     <0x2 0x13 0x7 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "usbin-plugin",
+					  "bat-ov",
+					  "wdog-bark",
+					  "usbin-icl-change";
+
+			io-channels = <&pm8150b_adc 7>,
+				      <&pm8150b_adc 8>;
+			io-channel-names = "usb_in_i_uv", "usb_in_v_div_16";
+
+			status = "disabled";
+		};
+
 		pm8150b_adc: adc@3100 {
 			compatible = "qcom,spmi-adc5";
 			reg = <0x3100>;
@@ -133,6 +153,18 @@
 				label = "die_temp";
 			};
 
+			channel@7 {
+				reg = <ADC5_USB_IN_I>;
+				qcom,pre-scaling = <1 1>;
+				label = "usb_in_i_uv";
+			};
+
+			channel@8 {
+				reg = <ADC5_USB_IN_V_16>;
+				qcom,pre-scaling = <1 16>;
+				label = "usb_in_v_div_16";
+			};
+
 			channel@9 {
 				reg = <ADC5_CHG_TEMP>;
 				qcom,pre-scaling = <1 1>;

From 7bfd2531772fbbb762778782796800ce3e879cf5 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:26:32 +0800
Subject: [PATCH 10/11] arm64: dts: qcom: pm8150b: Add a FG

---
 arch/arm64/boot/dts/qcom/pm8150b.dtsi | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/pm8150b.dtsi b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
index d0cfe63619547f..42ef21238f18bd 100644
--- a/arch/arm64/boot/dts/qcom/pm8150b.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
@@ -127,6 +127,14 @@
 			status = "disabled";
 		};
 
+		pm8150b_fg: fuel-gauge@4000 {
+			compatible = "qcom,pm8150b-fg";
+			reg = <0x4000>;
+			interrupts = <0x2 0x40 0x3 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "soc-delta";
+			status = "disabled";
+		};
+
 		pm8150b_adc: adc@3100 {
 			compatible = "qcom,spmi-adc5";
 			reg = <0x3100>;

From 73475e71a2196b2190c5ff73e761a0ccd19723eb Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 30 Sep 2024 17:27:42 +0700
Subject: [PATCH 11/11] arm64: dts: qcom: sm8250-retroid-rpmini: Add initial
 device tree

---
 arch/arm64/boot/dts/qcom/Makefile             |    1 +
 .../boot/dts/qcom/sm8250-retroid-rpmini.dts   | 1324 +++++++++++++++++
 2 files changed, 1325 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/sm8250-retroid-rpmini.dts

diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index 0e5c810304fbef..dd1bd4fe78ebf3 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -235,6 +235,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-sony-xperia-kumano-bahamut.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-sony-xperia-kumano-griffin.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-mtp.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-retroid-rpmini.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-sony-xperia-edo-pdx203.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-sony-xperia-edo-pdx206.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-xiaomi-elish-boe.dtb
diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroid-rpmini.dts b/arch/arm64/boot/dts/qcom/sm8250-retroid-rpmini.dts
new file mode 100644
index 00000000000000..4f9bc5b43a821a
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroid-rpmini.dts
@@ -0,0 +1,1324 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2024, Retroid Pocket.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/usb/pd.h>
+#include "sm8250.dtsi"
+#include "pm8150.dtsi"
+#include "pm8150b.dtsi"
+#include "pm8150l.dtsi"
+
+/ {
+	model = "Retroid Pocket Mini";
+	compatible = "retroid,rpmini", "qcom,sm8250";
+	qcom,msm-id = <356 0x20001>;
+	qcom,board-id = <0x01001F 0x01>;
+
+	aliases {
+		serial0 = &uart12;
+		serial1 = &uart6;
+		serial2 = &uart16;
+		sdhc2 = &sdhc_2;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+
+		charge-full-design-microamp-hours = <3850000>;
+		voltage-min-design-microvolt = <3600000>;
+		voltage-max-design-microvolt = <4400000>;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer: framebuffer@9c000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			width = <960>;
+			height = <1280>;
+			stride = <(960 * 4)>;
+			format = "a8r8g8b8";
+		};
+	};
+
+	fan: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-levels = <0 64 128 255>;
+		#cooling-cells = <2>;
+		fan-supply = <&fan_pwr>;
+		pwms = <&pm8150l_lpg 0 50000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fan_pwm_active>;
+
+		status = "disabled";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		key-vol-up {
+			label = "Volume Up";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&pm8150_gpios 6 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	thermal-zones {
+		conn-thermal {
+			thermal-sensors = <&pm8150b_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+
+		pm8150l-pcb-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+
+		skin-msm-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+
+		wifi-thermal {
+			thermal-sensors = <&pm8150_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <52000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+
+		xo-thermal {
+			thermal-sensors = <&pm8150_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+	};
+
+	vbat: vbat-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VBAT";
+		vin-supply = <&vreg_l11c_3p3>;
+		regulator-min-microvolt = <4200000>;
+		regulator-max-microvolt = <4200000>;
+		regulator-always-on;
+	};
+
+	vdc_3v3: vdc-3v3-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VDC_3V3";
+		vin-supply = <&vreg_l11c_3p3>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	vdc_5v: vdc-5v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VDC_5V";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+		vin-supply = <&vreg_l11c_3p3>;
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+		regulator-min-microvolt = <3700000>;
+		regulator-max-microvolt = <3700000>;
+		regulator-always-on;
+	};
+
+	vreg_s4a_1p8: vreg-s4a-1p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_s4a_1p8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vph_pwr>;
+	};
+
+	avdd_display_panel: avdd-display-panel {
+		compatible = "regulator-fixed";
+		regulator-name = "avdd_display_panel";
+
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+
+		gpio = <&tlmm 4 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+	};
+
+	fan_pwr: fan-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "fan_pwr";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&tlmm 7 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	mcu_3v3: mcu-3v3-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "mcu_3v3";
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 3 GPIO_ACTIVE_HIGH>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+	};
+
+	qca6390-pmu {
+		compatible = "qcom,qca6390-pmu";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&bt_en_state>, <&wlan_en_state>;
+
+		vddaon-supply = <&vreg_s6a_0p95>;
+		vddrfa1p3-supply = <&vreg_s8c_1p3>;
+		vddrfa1p9-supply = <&vreg_s5a_1p9>;
+		vddpcie1p3-supply = <&vreg_s8c_1p3>;
+		vddpcie1p9-supply = <&vreg_s5a_1p9>;
+		vddio-supply = <&vreg_s4a_1p8>;
+
+		wlan-enable-gpios = <&tlmm 20 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p7: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p7";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
+
+	wcd938x: audio-codec {
+		compatible = "qcom,wcd9385-codec";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&wcd_default>;
+
+		reset-gpios = <&tlmm 32 GPIO_ACTIVE_LOW>;
+
+		vdd-buck-supply = <&vreg_s4a_1p8>;
+		vdd-rxtx-supply = <&vreg_s4a_1p8>;
+		vdd-io-supply = <&vreg_s4a_1p8>;
+		vdd-mic-bias-supply = <&vreg_bob>;
+
+		qcom,micbias1-microvolt = <1800000>;
+		qcom,micbias2-microvolt = <1800000>;
+		qcom,micbias3-microvolt = <1800000>;
+		qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+		qcom,rx-device = <&wcd_rx>;
+		qcom,tx-device = <&wcd_tx>;
+
+		#sound-dai-cells = <1>;
+	};
+
+	reserved-memory {
+		cont_splash_mem: cont-splash@9c000000 {
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			no-map;
+		};
+	};
+};
+
+&adsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/retroidpocket/rpmini/adsp.mbn";
+};
+
+&apps_rsc {
+	regulators-0 {
+		compatible = "qcom,pm8150-rpmh-regulators";
+		qcom,pmic-id = "a";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-s9-supply = <&vph_pwr>;
+		vdd-s10-supply = <&vph_pwr>;
+		vdd-l2-l10-supply = <&vreg_bob>;
+		vdd-l3-l4-l5-l18-supply = <&vreg_s6a_0p95>;
+		vdd-l6-l9-supply = <&vreg_s8c_1p3>;
+		vdd-l7-l12-l14-l15-supply = <&vreg_s5a_1p9>;
+		vdd-l13-l16-l17-supply = <&vreg_bob>;
+
+		vreg_l2a_3p1: ldo2 {
+			regulator-name = "vreg_l2a_3p1";
+			regulator-min-microvolt = <3072000>;
+			regulator-max-microvolt = <3072000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3a_0p9: ldo3 {
+			regulator-name = "vreg_l3a_0p9";
+			regulator-min-microvolt = <928000>;
+			regulator-max-microvolt = <932000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5a_0p88: ldo5 {
+			regulator-name = "vreg_l5a_0p88";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6a_1p2: ldo6 {
+			regulator-name = "vreg_l6a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7a_1p7: ldo7 {
+			regulator-name = "vreg_l7a_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9a_1p2: ldo9 {
+			regulator-name = "vreg_l9a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10a_1p8: ldo10 {
+			regulator-name = "vreg_l10a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l12a_1p8: ldo12 {
+			regulator-name = "vreg_l12a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13a_ts_3p0: ldo13 {
+			regulator-name = "vreg_l13a_ts_3p0";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l14a_1p8: ldo14 {
+			regulator-name = "vreg_l14a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l15a_1p8: ldo15 {
+			regulator-name = "vreg_l15a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l16a_2p7: ldo16 {
+			regulator-name = "vreg_l16a_2p7";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l17a_3p0: ldo17 {
+			regulator-name = "vreg_l17a_3p0";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l18a_0p92: ldo18 {
+			regulator-name = "vreg_l18a_0p92";
+			regulator-min-microvolt = <800000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s5a_1p9: smps5 {
+			regulator-name = "vreg_s5a_1p9";
+			regulator-min-microvolt = <1904000>;
+			regulator-max-microvolt = <2000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s6a_0p95: smps6 {
+			regulator-name = "vreg_s6a_0p95";
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <1128000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-1 {
+		compatible = "qcom,pm8150l-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-l1-l8-supply = <&vreg_s4a_1p8>;
+		vdd-l2-l3-supply = <&vreg_s8c_1p3>;
+		vdd-l4-l5-l6-supply = <&vreg_bob>;
+		vdd-l7-l11-supply = <&vreg_bob>;
+		vdd-l9-l10-supply = <&vreg_bob>;
+		vdd-bob-supply = <&vph_pwr>;
+
+		vreg_bob: bob {
+			regulator-name = "vreg_bob";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <4000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+
+		vreg_l1c_1p8: ldo1 {
+			regulator-name = "vreg_l1c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2c_1p2: ldo2 {
+			regulator-name = "vreg_l2c_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3c_1p2: ldo3 {
+			regulator-name = "vreg_l3c_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l4c_1p7: ldo4 {
+			regulator-name = "vreg_l4c_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5c_1p8: ldo5 {
+			regulator-name = "vreg_l5c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6c_2p96: ldo6 {
+			regulator-name = "vreg_l6c_2p96";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7c_cam_vcm0_2p85: ldo7 {
+			regulator-name = "vreg_l7c_cam_vcm0_2p85";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3104000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l8c_1p8: ldo8 {
+			regulator-name = "vreg_l8c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9c_2p96: ldo9 {
+			regulator-name = "vreg_l9c_2p96";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10c_3p0: ldo10 {
+			regulator-name = "vreg_l10c_3p0";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l11c_3p3: ldo11 {
+			regulator-name = "vreg_l11c_3p3";
+			regulator-min-microvolt = <3296000>;
+			regulator-max-microvolt = <3296000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+			regulator-always-on;
+		};
+
+		vreg_s8c_1p3: smps8 {
+			regulator-name = "vreg_s8c_1p3";
+			regulator-min-microvolt = <1352000>;
+			regulator-max-microvolt = <1352000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+};
+
+&cdsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/retroidpocket/rpmini/cdsp.mbn";
+};
+
+&gmu {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+
+	zap-shader {
+		memory-region = <&gpu_mem>;
+		firmware-name = "qcom/sm8250/retroidpocket/rpmini/a650_zap.mbn";
+	};
+};
+
+&i2c13 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+	touchscreen@38 {
+		compatible = "focaltech,ft5452";
+		reg = <0x38>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <39 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+		vcc-supply = <&vreg_l13a_ts_3p0>;
+		iovcc-supply = <&vreg_l1c_1p8>;
+
+		pinctrl-0 = <&ts_int_active &ts_reset_active>;
+		pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
+		pinctrl-names = "default", "sleep";
+
+		touchscreen-size-x = <960>;
+		touchscreen-size-y = <1280>;
+	};
+};
+
+&i2c15 {
+	status = "okay";
+
+	typec-mux@1c {
+		compatible = "onnn,nb7vpq904m";
+		reg = <0x1c>;
+
+	 	enable-gpios = <&tlmm 9 GPIO_ACTIVE_LOW>;
+
+		vcc-supply = <&vreg_s4a_1p8>;
+
+		retimer-switch;
+		orientation-switch;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				redriver_usb_con_ss: endpoint {
+					remote-endpoint = <&pm8150b_typec_mux_in>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				redriver_phy_con_ss: endpoint {
+					remote-endpoint = <&usb_1_qmpphy_out>;
+					data-lanes = <0 1 2 3>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				redriver_usb_con_sbu: endpoint {
+					remote-endpoint = <&pm8150b_typec_sbu_out>;
+				};
+			};
+		};
+	};
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dp {
+	status = "okay";
+};
+
+&mdss_dp_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&usb_1_qmpphy_dp_in>;
+};
+
+&mdss_dsi0 {
+	status = "okay";
+	vdda-supply = <&vreg_l9a_1p2>;
+
+	panel@0 {
+		compatible = "ddic,ch13726a";
+		reg = <0>;
+		reset-gpios = <&tlmm 75 GPIO_ACTIVE_HIGH>;
+
+		vdd1v2-supply = <&vreg_l3c_1p2>;
+		vddio-supply = <&vreg_l14a_1p8>;
+		vdd-supply = <&vreg_l11c_3p3>;
+		avdd-supply = <&avdd_display_panel>;
+
+		rotation = <90>;
+
+		pinctrl-0 = <&sde_dsi_active &sde_te_active>;
+		pinctrl-1 = <&sde_dsi_sleep &sde_te_sleep>;
+		pinctrl-names = "default", "sleep";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				panel_in_0: endpoint {
+					remote-endpoint = <&mdss_dsi0_out>;
+				};
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in_0>;
+};
+
+&mdss_dsi0_phy {
+	status = "okay";
+	vdds-supply = <&vreg_l5a_0p88>;
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&pcie0_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pcieport0 {
+	wifi@0 {
+		compatible = "pci17cb,1101";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
+&pcie1 {
+	status = "okay";
+};
+
+&pcie1_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pcie2 {
+	status = "okay";
+};
+
+&pcie2_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pm8150_adc {
+	channel@4c {
+		reg = <ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "xo_therm";
+	};
+
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "wifi_therm";
+	};
+};
+
+&pm8150_adc_tm {
+	status = "okay";
+
+	xo-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150_adc ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	wifi-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150b_adc {
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "conn_therm";
+	};
+};
+
+&pm8150b_adc_tm {
+	status = "okay";
+
+	conn-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150b_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150b_charger {
+	monitored-battery = <&battery>;
+	status = "okay";
+};
+
+&pm8150b_fg {
+	status = "okay";
+	monitored-battery = <&battery>;
+	power-supplies = <&pm8150b_charger>;
+};
+
+&pm8150b_typec {
+	status = "okay";
+
+	vdd-pdphy-supply = <&vreg_l2a_3p1>;
+
+	connector {
+		compatible = "usb-c-connector";
+
+		power-role = "dual";
+		data-role = "dual";
+		try-power-role = "sink";
+		self-powered;
+
+		source-pdos = <PDO_FIXED(5000, 3000,
+					 PDO_FIXED_DUAL_ROLE |
+					 PDO_FIXED_USB_COMM |
+					 PDO_FIXED_DATA_SWAP)>;
+
+		sink-pdos = <PDO_FIXED(5000, 3000,
+					 PDO_FIXED_DUAL_ROLE |
+					 PDO_FIXED_USB_COMM |
+					 PDO_FIXED_DATA_SWAP)>;
+
+		op-sink-microwatt = <15000000>;
+
+		altmodes {
+			displayport {
+				svid = /bits/ 16 <0xff01>;
+				vdo = <0x00001c46>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				pm8150b_hs_in: endpoint {
+					remote-endpoint = <&usb_1_dwc3_hs_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				pm8150b_typec_mux_in: endpoint {
+					remote-endpoint = <&redriver_usb_con_ss>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				pm8150b_typec_sbu_out: endpoint {
+					remote-endpoint = <&redriver_usb_con_sbu>;
+				};
+			};
+		};
+	};
+};
+
+&pm8150b_vbus {
+	regulator-min-microamp = <500000>;
+	regulator-max-microamp = <3000000>;
+	status = "okay";
+};
+
+&pm8150l_adc {
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "skin_msm_therm";
+	};
+
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "pm8150l_therm";
+	};
+};
+
+&pm8150l_adc_tm {
+	status = "okay";
+
+	skin-msm-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	pm8150l-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150l_gpios {
+	fan_pwm_active: fan-pwm-active-state {
+		pins = "gpio6";
+		function = "func1";
+		bias-disable;
+		qcom,drive-strength = <3>;
+		power-source = <0>;
+		output-high;
+	};
+};
+
+&pm8150l_lpg {
+	status = "okay";
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&pon_resin {
+	status = "okay";
+
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+	};
+
+	dai@1 {
+		reg = <1>;
+	};
+
+	dai@2 {
+		reg = <2>;
+	};
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&qupv3_id_2 {
+	status = "okay";
+};
+
+&rxmacro {
+	status = "okay";
+};
+
+&sdhc_2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdc2_default_state &sdc2_card_det_n>;
+	vmmc-supply = <&vreg_l9c_2p96>;
+	vqmmc-supply = <&vreg_l6c_2p96>;
+	cd-gpios = <&tlmm 77 GPIO_ACTIVE_LOW>;
+	bus-width = <4>;
+	no-sdio;
+	no-mmc;
+};
+
+&sound {
+	compatible = "qcom,sm8250-sndcard";
+	model = "RPMini";
+	audio-routing =
+		"SpkrLeft IN", "WSA_SPK1 OUT",
+		"SpkrRight IN", "WSA_SPK2 OUT",
+		"IN1_HPHL", "HPHL_OUT",
+		"IN2_HPHR", "HPHR_OUT",	
+		"MM_DL1",  "MultiMedia1 Playback",
+		"MM_DL2",  "MultiMedia2 Playback",
+		"MultiMedia3 Capture", "MM_UL3";
+
+	mm1-dai-link {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	mm2-dai-link {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	mm3-dai-link {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	wcd-playback-dai-link {
+		link-name = "WCD Playback";
+		cpu {
+			sound-dai = <&q6afedai RX_CODEC_DMA_RX_0>;
+		};
+		codec {
+			sound-dai = <&wcd938x 0>, <&swr1 0>, <&rxmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wsa-dai-link {
+		link-name = "WSA Playback";
+		cpu {
+			sound-dai = <&q6afedai WSA_CODEC_DMA_RX_0>;
+		};
+
+		codec {
+			sound-dai = <&left_spkr>, <&right_spkr>, <&swr0 0>, <&wsamacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wcd-capture-dai-link {
+		link-name = "WCD Capture";
+		cpu {
+			sound-dai = <&q6afedai TX_CODEC_DMA_TX_3>;
+		};
+
+		codec {
+			sound-dai = <&wcd938x 1>, <&swr2 0>, <&txmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+};
+
+&swr0 {
+	status = "okay";
+
+	left_spkr: speaker@0,1 {
+		compatible = "sdw10217201000";
+		reg = <0 1>;
+		powerdown-gpios = <&tlmm 129 GPIO_ACTIVE_LOW>;
+		#thermal-sensor-cells = <0>;
+		sound-name-prefix = "SpkrLeft";
+		#sound-dai-cells = <0>;
+	};
+
+	right_spkr: speaker@0,2 {
+		compatible = "sdw10217201000";
+		reg = <0 2>;
+		powerdown-gpios = <&tlmm 127 GPIO_ACTIVE_LOW>;
+		#thermal-sensor-cells = <0>;
+		sound-name-prefix = "SpkrRight";
+		#sound-dai-cells = <0>;
+	};
+};
+
+&swr1 {
+	status = "okay";
+
+	wcd_rx: wcd9385-rx@0,4 {
+		compatible = "sdw20217010d00";
+		reg = <0 4>;
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+
+	wcd_tx: wcd9385-tx@0,3 {
+		compatible = "sdw20217010d00";
+		reg = <0 3>;
+		qcom,tx-port-mapping = <2 3 4 5>;
+	};
+};
+
+&tlmm {
+	bt_en_state: bt-default-state {
+		pins = "gpio21";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+
+	mcu_default: mcu-default-state {
+		pins = "gpio111";
+		function = "gpio";
+		bias-pull-down;
+	};
+
+	sdc2_default_state: sdc2-default-state {
+		clk-pins {
+			pins = "sdc2_clk";
+			bias-disable;
+			drive-strength = <16>;
+		};
+
+		cmd-pins {
+			pins = "sdc2_cmd";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		data-pins {
+			pins = "sdc2_data";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+	};
+
+	sdc2_card_det_n: sd-card-det-n-state {
+		pins = "gpio77";
+		function = "gpio";
+		bias-pull-up;
+	};
+
+	sde_dsi_active: sde-dsi-active-state {
+		pins = "gpio75";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	sde_dsi_sleep: sde-dsi-sleep-state {
+		pins = "gpio75";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sde_te_active: sde-te-active-state {
+		pins = "gpio66";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sde_te_sleep: sde-te-sleep-state {
+		pins = "gpio66";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_int_active: ts-int-active-state {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	ts_int_suspend: ts-int-suspend-state {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_reset_active: ts-reset-active-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	ts_reset_suspend: ts-reset-suspend-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	wcd_default: wcd-default-state {
+		reset-pins {
+			pins = "gpio32";
+			function = "gpio";
+			bias-disable;
+		};
+	};
+
+	wlan_en_state: wlan-default-state {
+		pins = "gpio20";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+};
+
+&txmacro {
+	status = "okay";
+};
+
+&uart6 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,qca6390-bt";
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddbtcmx-supply = <&vreg_pmu_btcmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+	};
+};
+
+&uart12 {
+	status = "okay";
+};
+
+&uart16 {
+	status = "okay";
+
+	gamepad {
+		compatible = "ayn,odin2-gamepad";
+		vdd-supply = <&mcu_3v3>;
+		enable-gpios = <&tlmm 111 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&mcu_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&ufs_mem_hc {
+	status = "okay";
+
+	vcc-supply = <&vreg_l17a_3p0>;
+	vcc-max-microamp = <800000>;
+	vccq-supply = <&vreg_l6a_1p2>;
+	vccq-max-microamp = <800000>;
+	vccq2-supply = <&vreg_s4a_1p8>;
+	vccq2-max-microamp = <800000>;
+};
+
+&ufs_mem_phy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&usb_1 {
+	status = "okay";
+};
+
+&usb_1_dwc3 {
+	dr_mode = "otg";
+	usb-role-switch;
+};
+
+&usb_1_dwc3_hs_out {
+	remote-endpoint = <&pm8150b_hs_in>;
+};
+
+&usb_1_hsphy {
+	status = "okay";
+
+	vdda-pll-supply = <&vreg_l5a_0p88>;
+	vdda33-supply = <&vreg_l2a_3p1>;
+	vdda18-supply = <&vreg_l12a_1p8>;
+};
+
+&usb_1_qmpphy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l9a_1p2>;
+	vdda-pll-supply = <&vreg_l18a_0p92>;
+};
+
+&usb_1_qmpphy_dp_in {
+	remote-endpoint = <&mdss_dp_out>;
+};
+
+&usb_1_qmpphy_out {
+	remote-endpoint = <&redriver_phy_con_ss>;
+};
+
+&venus {
+	firmware-name = "qcom/sm8250/retroidpocket/rpmini/venus.mbn";
+	status = "okay";
+};
+
+&wsamacro {
+	status = "okay";
+};
